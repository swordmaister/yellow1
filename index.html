<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR — 最終操作版</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<style>
  html, body { height: 100%; margin: 0; background: #87CEEB; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
  canvas { display: block; width: 100%; height: 100%; }

  #error-log { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:#ff5555; padding:20px; z-index:9999; white-space:pre-wrap; font-weight:bold; overflow:auto; }
  #damage-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: red; opacity: 0; pointer-events: none; z-index: 50; transition: opacity 0.1s; }

  #hud { position: fixed; top: 16px; left: 16px; pointer-events: none; z-index: 10; }
  .hud-box { background: rgba(0, 30, 60, 0.7); padding: 8px 16px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); margin-bottom: 8px; backdrop-filter: blur(4px); min-width: 140px; }
  .big-text { font-size: 18px; font-weight: bold; color: #ffeb3b; text-shadow: 1px 1px 2px #000; }
  .sub-text { font-size: 14px; color: #e0e0e0; }
  .hp-bar-bg { width: 100%; height: 8px; background: #555; margin-top: 4px; border-radius: 4px; overflow: hidden; }
  .hp-bar-val { width: 100%; height: 100%; background: #0f0; transition: width 0.2s; }

  #msgArea { position: fixed; top: 35%; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
  .flash-msg { font-size: 40px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #f0a, 2px 2px 0 #000; opacity: 0; transition: opacity 0.3s; }

  /* VRボタン装飾 */
  #vrBtn { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; background: rgba(0,0,0,0.8); border: 3px solid #0f0; color: #fff; border-radius: 12px; z-index: 200; pointer-events: auto; font-weight: bold; font-size: 24px; cursor: pointer; box-shadow: 0 0 20px #0f0; }
</style>

<script>
  window.onerror = function(msg, url, line) {
    const box = document.getElementById('error-log');
    box.style.display = 'block';
    box.textContent += "Error: " + msg + "\nLine: " + line + "\n";
    return false;
  };
</script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>

<div id="error-log"></div>
<div id="damage-overlay"></div>

<div id="hud">
  <div class="hud-box">
    <span class="big-text" id="waveVal">WAVE 1</span><br>
    <span class="sub-text">撃破: <span id="killVal">0</span> / 残: <span id="targetVal" style="color:#f88;">3</span></span>
  </div>
  <div class="hud-box">
    <span class="sub-text">HP: <span id="hpText">100</span></span>
    <div class="hp-bar-bg"><div id="hpBar" class="hp-bar-val"></div></div>
  </div>
  <div class="hud-box" id="vipBox" style="display:none; border-color:#0f0;">
    <span class="sub-text" style="color:#0f0;">護衛対象</span>
    <div class="hp-bar-bg"><div id="vipHpBar" class="hp-bar-val" style="background:#0ff;"></div></div>
  </div>
  <div class="hud-box">
    <span class="sub-text">結界: <span id="kekVal" style="color:#00bfff;">0</span>/5</span>
  </div>
</div>

<div id="msgArea"><div id="flashMsg" class="flash-msg"></div></div>
<button id="vrBtn">VR START</button>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

const CFG = {
  colors: {
    sky: 0x87CEEB, ground: 0xC2B280, 
    kekkai: 0x00bfff, ghost: 0x00ffaa, marker: 0xff0000,
    wall: 0xa0a0a0, building: 0xf0f0f0, pool: 0x88cccc,
    enemy: 0xff4444, giant: 0x880000, item: 0x00ff00, vip: 0x0000ff
  },
  player: { speed: 8.0, jump: 15.0, height: 1.7, maxHp: 100 },
  kekkai: { max: 5 }, dist: { near: 8.0, far: 20.0 }, field: { width: 120, depth: 160 }
};

let scene, camera, renderer, world;
let playerBody, playerGroup;
let enemies = [], kekkaiList = [], items = [], vip = null;
let gameState = { wave: 1, kills: 0, req: 3, nextSpawn: 0, playerHp: 100, isVipMode: false };
let currentDist = CFG.dist.near, aimMarker;
let controllers = { left: null, right: null };
let controllerGrips = { left: null, right: null };

// Global UI Elements
const els = {
  msg: document.getElementById('flashMsg'),
  hpText: document.getElementById('hpText'), hpBar: document.getElementById('hpBar'),
  dmgOverlay: document.getElementById('damage-overlay'),
  vipBox: document.getElementById('vipBox'), vipHpBar: document.getElementById('vipHpBar'),
  kekVal: document.getElementById('kekVal'),
  wVal: document.getElementById('waveVal'), kVal: document.getElementById('killVal'), tVal: document.getElementById('targetVal')
};

// Global Logic State
let activeKekkai = null; // 現在作成中の結界情報
let camAngle = { yaw: 0 };
let stickMove = { x: 0, y: 0 };
let lastT = 0;
// ボタン状態管理 (単押し判定用)
let btnState = { rightA: false, rightB: false, leftX: false, rightTrig: false, leftTrig: false, rightStickX: 0 };

function init() {
  try {
    scene = new THREE.Scene(); scene.background = new THREE.Color(CFG.colors.sky); 
    scene.fog = new THREE.FogExp2(CFG.colors.sky, 0.005);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    playerGroup = new THREE.Group(); 
    playerGroup.add(camera); 
    // 初期位置
    playerGroup.position.set(0, CFG.player.height, 30);
    scene.add(playerGroup);
    
    renderer = new THREE.WebGLRenderer({ antialias: true }); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    renderer.shadowMap.enabled = true; 
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.xr.enabled = true; 
    renderer.xr.setReferenceSpaceType('local-floor');
    document.body.appendChild(renderer.domElement);

    // VRボタン設定
    const vrBtnElement = VRButton.createButton(renderer);
    document.body.appendChild(vrBtnElement);
    document.getElementById('vrBtn').style.display = 'none';

    // コントローラー設定
    setupControllers();

    // 物理エンジン
    world = new CANNON.World(); world.gravity.set(0, -25, 0);
    const mDef=new CANNON.Material('def'), mPly=new CANNON.Material('ply'), mEne=new CANNON.Material('ene'), mKek=new CANNON.Material('kek');
    
    world.addContactMaterial(new CANNON.ContactMaterial(mPly, mDef, { friction: 0.0, restitution: 0.0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mEne, mDef, { friction: 0.5, restitution: 0.3 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek, mEne, { friction: 0.1, restitution: 0.8 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek, mPly, { friction: 0.8, restitution: 0.0 }));

    // プレイヤー物理 (球体)
    playerBody = new CANNON.Body({ mass: 70, shape: new CANNON.Sphere(0.5), material: mPly, fixedRotation: true, linearDamping: 0.9 });
    playerBody.position.set(0, 5, 30); 
    world.addBody(playerBody);

    // 衝突判定
    playerBody.addEventListener('collide', (e) => {
      if (e.body && e.body.material && e.body.material.name === 'ene') {
        const relVel = e.contact.getImpactVelocityAlongNormal();
        if (Math.abs(relVel) > 2.0) {
          takeDamage(Math.floor(Math.abs(relVel) * 2));
          const normal = new CANNON.Vec3(); e.contact.ni.negate(normal);
          playerBody.applyImpulse(normal.scale(50 * Math.abs(relVel)), playerBody.position);
        }
      }
    });

    setupEnvironment(mDef);
    
    // 照準マーカー (赤い点)
    const aimGeo = new THREE.SphereGeometry(0.3, 16, 16);
    const aimMat = new THREE.MeshBasicMaterial({ color: CFG.colors.marker, transparent: true, opacity: 0.8, depthTest: false });
    aimMarker = new THREE.Mesh(aimGeo, aimMat); 
    aimMarker.renderOrder = 999; 
    scene.add(aimMarker);

    for (let i = 0; i < 3; i++) spawnEnemy(); 
    renderer.setAnimationLoop(loop);

  } catch (e) { console.error(e); alert("初期化エラー: " + e.message); }
}

function setupControllers() {
    const controllerModelFactory = new XRControllerModelFactory();

    // Controller 0 (Right usually)
    const c0 = renderer.xr.getController(0);
    c0.addEventListener('connected', (e) => { c0.userData.handedness = e.data.handedness; controllers[e.data.handedness] = c0; });
    c0.addEventListener('disconnected', (e) => { controllers[e.data.handedness] = null; });
    playerGroup.add(c0);
    const g0 = renderer.xr.getControllerGrip(0);
    g0.add(controllerModelFactory.createControllerModel(g0));
    playerGroup.add(g0);
    controllerGrips.right = g0; // 仮置き

    // Controller 1 (Left usually)
    const c1 = renderer.xr.getController(1);
    c1.addEventListener('connected', (e) => { c1.userData.handedness = e.data.handedness; controllers[e.data.handedness] = c1; });
    c1.addEventListener('disconnected', (e) => { controllers[e.data.handedness] = null; });
    playerGroup.add(c1);
    const g1 = renderer.xr.getControllerGrip(1);
    g1.add(controllerModelFactory.createControllerModel(g1));
    playerGroup.add(g1);
    controllerGrips.left = g1;
}

// --- Main Loop ---
function loop(t) {
  const dt = Math.min((t - lastT) / 1000, 0.1); lastT = t;
  world.step(1 / 60, dt, 3);

  handleVRInput(); // 入力処理
  updatePlayerMovement(); // 移動処理
  updateAimMarker(); // 照準更新
  updateGameLogic(dt, t); // 敵AIなど

  renderer.render(scene, camera);
}

// --- VR Input Handling (Quest 2 Optimized) ---
function handleVRInput() {
  const session = renderer.xr.getSession();
  if (!session) return;

  // 左右のコントローラーをチェック
  for (const source of session.inputSources) {
    if (!source.gamepad) continue;
    const gp = source.gamepad;
    const hand = source.handedness;
    const controller = controllers[hand];

    // --- 左手 (Left) ---
    if (hand === 'left') {
      // 1. 移動 (サムスティック) axes[2], axes[3]
      if (gp.axes.length >= 4) {
        stickMove.x = gp.axes[2];
        stickMove.y = gp.axes[3];
      }
      
      // 2. ジャンプ (Xボタン: button[3] or [4] depending on browser/profile. Usually X is 3 in standard mapping)
      // Quest: A=4, B=5, X=?, Y=?. Often X is mapped to 3. Let's try standard mapping index.
      // Standard: 0:Trig, 1:Grip, 2:?, 3:StickPress, 4:A/X, 5:B/Y
      // Quest browser mapping can vary. Usually X is 4 on Left controller if mapped same as A on Right.
      if (gp.buttons[4] && gp.buttons[4].pressed && Math.abs(playerBody.velocity.y) < 1) {
        playerBody.velocity.y = CFG.player.jump;
      }

      // 3. 顕現結界 (物理) (グリップボタン: button[1])
      if (gp.buttons[1] && gp.buttons[1].pressed) {
        processKekkaiCreation(true, controller); // true = Physical
      } else {
        // 離したら確定
        if (activeKekkai && activeKekkai.hand === 'left') finalizeKekkai();
      }

      // 4. 解 (結界解除) (トリガー: button[0])
      if (gp.buttons[0] && gp.buttons[0].pressed) {
        if (!btnState.leftTrig) actionKai();
        btnState.leftTrig = true;
      } else {
        btnState.leftTrig = false;
      }
    }

    // --- 右手 (Right) ---
    if (hand === 'right') {
      // 1. 視点回転 (サムスティック X軸: axes[2])
      if (gp.axes.length >= 4) {
        const x = gp.axes[2];
        // スナップターン
        if (Math.abs(x) > 0.5 && Math.abs(btnState.rightStickX) <= 0.5) {
            camAngle.yaw -= Math.sign(x) * (Math.PI / 4); // 45度回転
        }
        btnState.rightStickX = x;
      }

      // 2. ゴースト結界 (グリップボタン: button[1])
      if (gp.buttons[1] && gp.buttons[1].pressed) {
        processKekkaiCreation(false, controller); // false = Ghost
      } else {
         if (activeKekkai && activeKekkai.hand === 'right') finalizeKekkai();
      }

      // 3. 滅 (トリガー: button[0])
      if (gp.buttons[0] && gp.buttons[0].pressed) {
        if (!btnState.rightTrig) actionMetsu();
        btnState.rightTrig = true;
      } else {
        btnState.rightTrig = false;
      }

      // 4. 距離切り替え
      // Aボタン (button[4]) -> 近
      if (gp.buttons[4] && gp.buttons[4].pressed) {
        if (!btnState.rightA) { currentDist = CFG.dist.near; showMsg("距離：近", "#fff"); }
        btnState.rightA = true;
      } else { btnState.rightA = false; }

      // Bボタン (button[5]) -> 遠
      if (gp.buttons[5] && gp.buttons[5].pressed) {
        if (!btnState.rightB) { currentDist = CFG.dist.far; showMsg("距離：遠", "#fff"); }
        btnState.rightB = true;
      } else { btnState.rightB = false; }
    }
  }
}

// プレイヤー移動処理 (カメラの向き基準)
function updatePlayerMovement() {
  // カメラのY回転だけ取得
  const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), camAngle.yaw);
  const right = new THREE.Vector3(-1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), camAngle.yaw); // 左手座標系注意

  // Stick Input (y is forward/back, x is left/right)
  const moveVec = forward.clone().multiplyScalar(-stickMove.y).add(right.clone().multiplyScalar(-stickMove.x));
  
  if (moveVec.length() > 1) moveVec.normalize();
  
  playerBody.velocity.x = moveVec.x * CFG.player.speed;
  playerBody.velocity.z = moveVec.z * CFG.player.speed;

  // プレイヤーグループ（カメラ親）の位置と回転を同期
  playerGroup.position.copy(playerBody.position);
  // Y座標補正（目の高さ）はCameraがLocalPosition(0, 1.7, 0)を持っている前提なら不要だが、
  // Questはカメラ位置自体が動くので、playerGroupのYは足元(Body位置)に合わせる
  // ただしCannonのSphereは中心基準なので、半径分(0.5)下げる等の調整が必要
  playerGroup.position.y -= 0.5; 
  playerGroup.rotation.y = camAngle.yaw;
}

// 照準更新 (プレイヤー正面 + 距離)
function updateAimMarker() {
  if (!playerGroup || !aimMarker) return;
  // プレイヤーの向き + 距離
  const offset = new THREE.Vector3(0, 0, -currentDist).applyAxisAngle(new THREE.Vector3(0, 1, 0), camAngle.yaw);
  const targetPos = playerGroup.position.clone().add(offset);
  targetPos.y = Math.max(0.5, targetPos.y); // 地面に埋まらない
  aimMarker.position.copy(targetPos);
}

// --- 結界システム (トラッキング対応) ---
function processKekkaiCreation(isPhysical, controller) {
  // 新規作成
  if (!activeKekkai) {
    if (kekkaiList.length >= CFG.kekkai.max) { showMsg("上限到達", "#f44"); return; }
    
    // 中心点
    const center = aimMarker.position.clone();
    // コントローラーの開始位置を記録 (ローカル座標系ではなくワールドで)
    const handPos = controller.position.clone(); 
    // ※Controller object position is relative to playerGroup usually. Get World Pos.
    const handWorldPos = new THREE.Vector3();
    controller.getWorldPosition(handWorldPos);

    activeKekkai = {
      center: center,
      startHand: handWorldPos,
      isPhysical: isPhysical,
      hand: isPhysical ? 'left' : 'right', // どちらの手で作っているか
      mesh: null,
      body: null
    };

    // 初期メッシュ生成
    const g = new THREE.BoxGeometry(1, 1, 1);
    const col = isPhysical ? 0xffff00 : CFG.colors.ghost;
    const m = new THREE.MeshPhongMaterial({ color: col, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(g, m);
    mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff })));
    mesh.position.copy(center);
    mesh.rotation.y = camAngle.yaw; // プレイヤーの向きに合わせる
    scene.add(mesh);
    activeKekkai.mesh = mesh;

    // 物理ならBodyも作る
    if (isPhysical) {
      const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek') });
      b.position.copy(center);
      b.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), camAngle.yaw);
      world.addBody(b);
      activeKekkai.body = b;
    }
  } 
  // 拡大処理 (ドラッグ)
  else {
    const currentHand = new THREE.Vector3();
    controller.getWorldPosition(currentHand);
    
    // 差分計算 (絶対値で拡大)
    const dx = Math.abs(currentHand.x - activeKekkai.startHand.x);
    const dy = Math.abs(currentHand.y - activeKekkai.startHand.y);
    const dz = Math.abs(currentHand.z - activeKekkai.startHand.z);

    // 感度調整
    const scaleFactor = 4.0;
    const sx = 1.0 + Math.max(dx, dz) * scaleFactor; // 横・奥行きは手の水平移動
    const sy = 1.0 + dy * scaleFactor;               // 高さは手の垂直移動
    const sz = sx; // 正方形ベース

    // メッシュ更新
    activeKekkai.mesh.scale.set(sx, sy, sz);
    // Y位置調整 (底面固定で上に伸ばす)
    const newY = activeKekkai.center.y + (sy - 1.0) / 2;
    activeKekkai.mesh.position.y = newY;

    // 物理更新
    if (activeKekkai.body) {
      activeKekkai.body.position.y = newY;
      // CannonはShapeを再生成する必要がある
      activeKekkai.body.shapes = [];
      activeKekkai.body.addShape(new CANNON.Box(new CANNON.Vec3(sx / 2, sy / 2, sz / 2)));
    }
    
    // データ保存
    activeKekkai.currentSize = { x: sx, y: sy, z: sz };
  }
}

function finalizeKekkai() {
  if (!activeKekkai) return;
  const k = activeKekkai;
  
  // ゴーストだった場合、ここで実体化(Body作成)
  if (!k.isPhysical) {
    const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek') });
    b.position.copy(k.mesh.position);
    const q = new CANNON.Quaternion(); q.setFromAxisAngle(new CANNON.Vec3(0,1,0), k.mesh.rotation.y);
    b.quaternion.copy(q);
    const s = k.currentSize || {x:1, y:1, z:1};
    // 中空の箱を作る (6面)
    const t = 0.5, x = s.x/2, y = s.y/2, z = s.z/2;
    const addW = (dim, off) => b.addShape(new CANNON.Box(dim), off);
    addW(new CANNON.Vec3(t, y, z), new CANNON.Vec3(-x, 0, 0));
    addW(new CANNON.Vec3(t, y, z), new CANNON.Vec3(x, 0, 0));
    addW(new CANNON.Vec3(x, t, z), new CANNON.Vec3(0, -y, 0));
    addW(new CANNON.Vec3(x, t, z), new CANNON.Vec3(0, y, 0));
    addW(new CANNON.Vec3(x, y, t), new CANNON.Vec3(0, 0, -z));
    addW(new CANNON.Vec3(x, y, t), new CANNON.Vec3(0, 0, z));
    
    world.addBody(b);
    k.body = b;
  }
  
  // 色変更
  k.mesh.material.color.setHex(CFG.colors.kekkai);
  k.mesh.material.opacity = 0.3;
  
  kekkaiList.push({ body: k.body, mesh: k.mesh, shrinking: false });
  spawnText(k.isPhysical ? "顕" : "結", k.mesh.position, "#0ff");
  
  activeKekkai = null;
  updateHUD();
}

function actionMetsu() {
  // 一番近い結界を探す
  let t = null, minD = 999; 
  kekkaiList.forEach(k => { 
    const d = playerBody.position.distanceTo(k.body.position); 
    if (d < minD) { minD = d; t = k; } 
  });
  
  if (!t || t.shrinking) { showMsg("対象なし", "#888"); return; }
  
  showMsg("滅！", "#f24"); 
  spawnText("滅", t.mesh.position, "#f24"); 
  t.shrinking = true; 
  t.mesh.material.color.setHex(0xff0044);
  
  // 演出用タイマー
  let progress = 0;
  const bbox = new THREE.Box3().setFromObject(t.mesh);

  const loop = () => {
    if (!kekkaiList.includes(t)) return;
    progress += 0.05;
    const scale = 1.0 - progress;
    t.mesh.scale.setScalar(scale);

    // 内部の敵にダメージ
    enemies.forEach(e => {
       if (bbox.containsPoint(e.mesh.position)) {
         // 中心へ吸い寄せ
         const d = t.body.position.vsub(e.body.position);
         e.body.velocity.set(d.x * 5, d.y * 5, d.z * 5);
         if (scale < 0.4) killEnemy(e);
       }
    });

    if (scale <= 0.1) {
      removeKekkai(t);
      spawnParticle(t.mesh.position, 30, 0xffaa00);
    } else {
      requestAnimationFrame(loop);
    }
  };
  loop();
}

function actionKai() {
  const t = kekkaiList[kekkaiList.length - 1]; 
  if (t) { 
    showMsg("解", "#4f8"); spawnText("解", t.mesh.position, "#4f8"); 
    removeKekkai(t); 
    // 文字を消す処理はspawnText内で行われる
  } else { 
    showMsg("結界なし", "#888"); 
  } 
}

function removeKekkai(k) {
  scene.remove(k.mesh); world.removeBody(k.body); 
  kekkaiList = kekkaiList.filter(o => o !== k); 
  updateHUD();
}

// --- Game Logic ---
function updateGameLogic(dt, t) {
  // Spawn
  if(t > gameState.nextSpawn) { spawnEnemy(); gameState.nextSpawn = t + 3000 - gameState.wave*100; }
  
  // Enemy Logic
  const fW=CFG.field.width, fD=CFG.field.depth;
  enemies.forEach(e=>{
    e.mesh.position.copy(e.body.position); e.mesh.quaternion.copy(e.body.quaternion);
    if(e.body.position.y < -10) killEnemy(e);
    
    // エリア外なら戻る
    const isOut = Math.abs(e.body.position.x) > fW/2+2 || Math.abs(e.body.position.z) > fD/2+2;
    if(isOut){
       if(!e.body.outsideTimer) e.body.outsideTimer=0; e.body.outsideTimer += dt;
       if(e.body.outsideTimer > 20.0) { removeEnemy(e); showMsg("敵逃亡!", "#aaa"); return; }
       // 中央上空へジャンプ
       const goal = new CANNON.Vec3(0, 20, 0);
       const dir = goal.vsub(e.body.position); dir.normalize();
       e.body.applyForce(dir.scale(50), e.body.position);
    } else {
       e.body.outsideTimer = 0;
       const target = (vip && vip.hp > 0) ? vip.body.position : playerBody.position;
       const d = target.vsub(e.body.position); d.normalize();
       e.body.applyForce(d.scale(e.isGiant ? 100 : 20), e.body.position);
       
       if (vip && e.body.position.distanceTo(vip.body.position) < 3.0 && Math.random() < 0.02) {
         vip.hp -= 5; spawnParticle(vip.body.position, 5, 0xff0000);
       }
    }
  });

  // Items
  items.forEach(it => {
    it.mesh.position.copy(it.body.position); it.mesh.rotation.y += 0.05;
    if (playerBody.position.distanceTo(it.body.position) < 2.0) {
      healPlayer(20); scene.remove(it.mesh); world.removeBody(it.body);
      items = items.filter(i => i !== it);
    }
  });

  // VIP
  if (vip) {
    vip.mesh.position.copy(vip.body.position);
    const tg = vip.goal.vsub(vip.body.position);
    if (tg.length() < 2.0) {
       showMsg("護衛成功!", "#0f0"); world.removeBody(vip.body); scene.remove(vip.mesh); vip=null; els.vipBox.style.display="none"; gameState.isVipMode=false;
    } else {
       tg.normalize();
       vip.body.velocity.x = tg.x * 7; vip.body.velocity.z = tg.z * 7; // Fast walk
       els.vipHpBar.style.width = vip.hp + "%";
       if (vip.hp <= 0) {
         showMsg("護衛失敗...", "#f00"); world.removeBody(vip.body); scene.remove(vip.mesh); vip=null; els.vipBox.style.display="none"; gameState.isVipMode=false;
       }
    }
  }
}

// ... (Environment setup code from previous steps included in full file) ...
// (Since environment code is long and stable, I'm abbreviating it here for the user's copy-paste convenience, assuming they want the FULL file)
// Re-inserting full setupEnvironment for completeness:

function setupEnvironment(mat){
  const sun=new THREE.DirectionalLight(0xffffee,1.2); sun.position.set(-50,100,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); scene.add(sun); scene.add(new THREE.AmbientLight(0x555566,0.6));
  const gGeo=new THREE.PlaneGeometry(CFG.field.width+40,CFG.field.depth+40); const gMat=new THREE.MeshStandardMaterial({color:CFG.colors.ground,roughness:0.9});
  const ground=new THREE.Mesh(gGeo,gMat); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
  const gBody=new CANNON.Body({mass:0,material:mat}); gBody.addShape(new CANNON.Plane()); gBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(gBody);

  const createBox=(x,y,z,w,h,d,col,tr=false,op=1)=>{
    const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col,transparent:tr,opacity:op})); m.position.set(x,y,z); m.castShadow=!tr; m.receiveShadow=true; scene.add(m);
    const b=new CANNON.Body({mass:0,material:mat}); b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))); b.position.copy(m.position); world.addBody(b); return m;
  };
  
  // Walls
  const FW=CFG.field.width,FD=CFG.field.depth,WH=8;
  createBox(0,WH/2,FD/2+1,FW+2,WH,2,CFG.colors.wall); createBox(-FW/2-1,WH/2,0,2,WH,FD+2,CFG.colors.wall); createBox(FW/2+1,WH/2,0,2,WH,FD+2,CFG.colors.wall);
  // Building
  const bH=30,bZ=-FD/2-20; createBox(0,bH/2,bZ,FW,bH,40,CFG.colors.building);
  
  // Slopes
  const stW=8, stRun=60, stRise=30, stZ=bZ+20+stW/2, slopeThickness=1.0, midY=stRise/2 - slopeThickness/2;
  const createSlope = (startX, endX) => {
    const run = Math.abs(endX - startX), len = Math.sqrt(run*run + stRise*stRise), ang = Math.atan2(stRise, run), midX = (startX + endX)/2;
    const b=new CANNON.Body({mass:0,material:mat}); b.addShape(new CANNON.Box(new CANNON.Vec3(len/2, slopeThickness/2, stW/2))); b.position.set(midX, midY, stZ);
    const dir = (endX > startX) ? 1 : -1; b.quaternion.setFromEuler(0, 0, dir * ang); world.addBody(b);
    const m=new THREE.Mesh(new THREE.BoxGeometry(len,slopeThickness,stW), new THREE.MeshStandardMaterial({color:0xdddddd})); m.position.copy(b.position); m.quaternion.copy(b.quaternion); scene.add(m);
    // Landing
    const landW=6, landX2 = endX + dir*(landW/2);
    createBox(startX - dir*(landW/2), 0.25, stZ, landW, 0.5, stW, 0xdddddd);
    createBox(landX2, stRise, stZ, landW, 0.5, stW, 0xdddddd);
    createBox(landX2, stRise, (stZ+(bZ+20))/2-10, landW, 0.5, 25, 0xdddddd);
  };
  createSlope(5, 55); createSlope(-5, -55);
  
  // Pool
  const pX=FW/2-25, pZ=0, pW=30, pD=60, wT=1.0;
  createBox(pX,1.0,pZ,pW,2.0,pD,CFG.colors.pool); createBox(pX,3.0,pZ-pD/2,pW,2.0,wT,CFG.colors.pool); createBox(pX,3.0,pZ+pD/2,pW,2.0,wT,CFG.colors.pool); createBox(pX-pW/2,3.0,pZ,wT,2.0,pD,CFG.colors.pool); createBox(pX+pW/2,3.0,pZ,wT,2.0,pD,CFG.colors.pool);
  const wtMat=new THREE.MeshBasicMaterial({color:0x00aaff, transparent:true, opacity:0.6, side:THREE.DoubleSide}), wt=new THREE.Mesh(new THREE.PlaneGeometry(pW-wT*2,pD-wT*2), wtMat);
  wt.rotation.x=-Math.PI/2; wt.position.set(pX,3.0,pZ); scene.add(wt);
  // Pool Slope
  const psW=4, psL=20, psX=pX-pW/2-psW/2, psZ=pZ, psH=3.0, psAng=Math.atan2(psH, psL);
  const psB=new CANNON.Body({mass:0,material:mat}); psB.addShape(new CANNON.Box(new CANNON.Vec3(psW/2, 0.2, Math.sqrt(psL*psL+psH*psH)/2)));
  psB.position.set(psX, psH/2-0.2, psZ); psB.quaternion.setFromEuler(-psAng,0,0); world.addBody(psB);
  const psM=new THREE.Mesh(new THREE.BoxGeometry(psW,0.4,Math.sqrt(psL*psL+psH*psH)), new THREE.MeshStandardMaterial({color:0xcccccc}));
  psM.position.copy(psB.position); psM.quaternion.copy(psB.quaternion); scene.add(psM);
}

// Helper funcs
function spawnEnemy(){
  if(enemies.length>=6+gameState.wave)return; const r=Math.random(); let x,y,z; const fW=CFG.field.width, fD=CFG.field.depth;
  if(r<0.6){x=(Math.random()-.5)*fW; z=(Math.random()-.5)*fD; y=20;} else {x=(fW/2-25)+(Math.random()-.5)*20; z=(Math.random()-.5)*50; y=10;}
  const sz=0.6+Math.random()*0.8, cl=new THREE.Color().setHSL(Math.random(),0.8,0.5), ms=15*sz;
  const b=new CANNON.Body({mass:ms,shape:new CANNON.Sphere(sz),material:new CANNON.Material('ene'),linearDamping:0.4}); b.position.set(x,y,z); world.addBody(b); b.outsideTimer=0;
  const m=new THREE.Mesh(new THREE.IcosahedronGeometry(sz,0), new THREE.MeshStandardMaterial({color:cl,roughness:0.3})); scene.add(m); enemies.push({body:b,mesh:m});
  if(Math.random()<0.2) spawnGiant(x,y,z);
}
function spawnGiant(x,y,z){
   const b=new CANNON.Body({mass:100,material:new CANNON.Material('ene'),linearDamping:0.5});
   b.addShape(new CANNON.Sphere(1.5)); b.position.set(x,y,z); world.addBody(b);
   const m=new THREE.Mesh(new THREE.SphereGeometry(1.5),new THREE.MeshStandardMaterial({color:CFG.colors.giant})); scene.add(m);
   enemies.push({body:b,mesh:m,isGiant:true,hp:5});
}
function removeEnemy(e){if(!enemies.includes(e))return;enemies=enemies.filter(o=>o!==e);scene.remove(e.mesh);world.removeBody(e.body);}

document.getElementById('vrBtn').addEventListener('click', ()=>{ if(navigator.xr) navigator.xr.requestSession('immersive-vr').then(s=>{ renderer.xr.setSession(s); document.getElementById('uiLayer').style.display='none'; }); });
window.onload = init;
</script>
</body>
</html>
