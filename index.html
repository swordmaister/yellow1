<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR — iOS Safari Final Fix</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">

<script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
    "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>

<style>
  html, body { height: 100%; margin: 0; background: #87CEEB; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
  canvas { display: block; width: 100%; height: 100%; }

  /* エラーログ（最前面表示） */
  #error-log { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); color:#ff5555; padding:20px; z-index:99999; white-space:pre-wrap; font-weight:bold; overflow:auto; pointer-events:auto; font-size:14px; }
  
  #hud { position: fixed; top: 16px; left: 16px; pointer-events: none; z-index: 10; }
  .hud-box { background: rgba(0, 30, 60, 0.7); padding: 8px 16px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); margin-bottom: 8px; backdrop-filter: blur(4px); min-width: 140px; }
  .big-text { font-size: 18px; font-weight: bold; color: #ffeb3b; text-shadow: 1px 1px 2px #000; }
  .sub-text { font-size: 14px; color: #e0e0e0; }
  .hp-bar-bg { width: 100%; height: 8px; background: #555; margin-top: 4px; border-radius: 4px; overflow: hidden; }
  .hp-bar-val { width: 100%; height: 100%; background: #0f0; transition: width 0.2s; }
  
  #msgArea { position: fixed; top: 35%; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
  .flash-msg { font-size: 40px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #f0a, 2px 2px 0 #000; opacity: 0; transition: opacity 0.3s; }

  /* VR起動ボタン */
  #vrStartBtn { display:none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 240px; padding: 15px; background: rgba(0,0,0,0.8); border: 2px solid #0f0; color: #0f0; border-radius: 30px; font-size: 18px; font-weight: bold; cursor: pointer; z-index: 200; text-align: center; box-shadow: 0 0 20px #0f0; }

  /* スマホUI */
  #mobileUI { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; transition: opacity 0.5s; }
  #stickZone { position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px; pointer-events: auto; }
  .stick-base { width: 100%; height: 100%; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; position: relative; }
  .stick-knob { width: 60px; height: 60px; background: #fff; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
  #padArea { position: absolute; bottom: 40px; right: 40px; width: 200px; height: 200px; pointer-events: none; }
  .btn { position: absolute; width: 65px; height: 65px; z-index: 10; border-radius: 50%; border: 2px solid rgba(255,255,255,0.6); background: rgba(40,50,80,0.8); color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; pointer-events: auto; touch-action: manipulation; }
  #btnUp { top: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #607d8b, #455a64); }
  #btnDown { bottom: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #9c27b0, #7b1fa2); width: 75px; height: 75px; font-size: 16px; }
  #btnLeft { top: 50%; left: 0; transform: translateY(-50%); background: linear-gradient(135deg, #f44336, #c62828); }
  #btnRight { top: 50%; right: 0; transform: translateY(-50%); background: linear-gradient(135deg, #03a9f4, #0288d1); width: 75px; height: 75px; font-size: 18px; }
  #btnRight.drawing { background: #fff; color: #0288d1; transform: translateY(-50%) scale(1.1); }
  #modeSwitch { position: absolute; top: -60px; right: 0; width: 120px; height: 40px; background: rgba(0,0,0,0.6); border: 2px solid #fff; border-radius: 20px; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:bold; pointer-events:auto; }
  #modeSwitch.phys { background: linear-gradient(90deg, #FFD700, #FF8C00); color:#000; border-color:#fff; }
  #modeSwitch.ghost { background: linear-gradient(90deg, #00bfff, #0000ff); color:#fff; border-color:#00ffff; }
  #centerReticle { position: fixed; top: 50%; left: 50%; width: 6px; height: 6px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: 1px solid rgba(0,0,0,0.5); }
</style>

<script>
  // 起動前チェック
  window.onerror = function(msg, url, line) {
    const box = document.getElementById('error-log');
    if(box){
        box.style.display = 'block';
        box.textContent += "【エラー】\n" + msg + "\n(Line: " + line + ")\n\n";
        
        // Script errorの場合のヒントを表示
        if(msg.indexOf('Script error') > -1 || line === 0) {
            box.textContent += "⚠️ ヒント: iPhoneでHTMLファイルを直接開いていませんか？\nWebXR機能を使うには、ローカルサーバー(http://...)か、GitHub PagesなどのWebサーバー(https://...)経由で開く必要があります。";
        }
        
        box.onclick = function() { box.style.display = 'none'; };
    }
  };
</script>

</head>
<body>

<div id="error-log"></div>
<div id="damage-overlay"></div>
<div id="hud">
  <div class="hud-box"><span class="big-text" id="waveVal">WAVE 1</span><br><span class="sub-text">撃破: <span id="killVal">0</span> / 残: <span id="targetVal" style="color:#f88;">3</span></span></div>
  <div class="hud-box"><span class="sub-text">HP: <span id="hpText">100</span></span><div class="hp-bar-bg"><div id="hpBar" class="hp-bar-val"></div></div></div>
  <div class="hud-box" id="vipBox" style="display:none; border-color:#0f0;"><span class="sub-text" style="color:#0f0;">護衛対象</span><div class="hp-bar-bg"><div id="vipHpBar" class="hp-bar-val" style="background:#0ff;"></div></div></div>
  <div class="hud-box"><span class="sub-text">結界: <span id="kekVal" style="color:#00bfff;">0</span>/5</span></div>
</div>
<div id="msgArea"><div id="flashMsg" class="flash-msg"></div></div>
<div id="centerReticle"></div>
<button id="vrStartBtn">VR MODE START</button>

<div id="mobileUI">
  <div id="stickZone"><div class="stick-base"><div id="stickKnob" class="stick-knob"></div></div></div>
  <div id="padArea">
    <div id="modeSwitch" class="ghost">モード: 幽体</div>
    <div id="btnUp" class="btn">距離<br><span id="distLabel" style="color:#fe0">近</span></div>
    <div id="btnLeft" class="btn">滅<br><span style="font-size:10px">⇔解</span></div>
    <div id="btnRight" class="btn">結<br><span style="font-size:10px">Hold</span></div>
    <div id="btnDown" class="btn">跳</div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

// --- CONFIG ---
const CFG = {
  colors: { sky: 0x87CEEB, ground: 0xC2B280, kekkai: 0x00bfff, ghost: 0x00ffaa, marker: 0xff0000, wall: 0xa0a0a0, building: 0xf0f0f0, pool: 0x88cccc, enemy: 0xff4444, giant: 0x880000, item: 0x00ff00, vip: 0x0000ff, treeTrunk: 0x8B4513, treeLeaf: 0x228B22 },
  player: { speed: 12.0, jump: 22.0, height: 1.7, maxHp: 100 },
  kekkai: { max: 5 }, dist: { near: 8.0, far: 20.0 }, field: { width: 120, depth: 160 }
};
const GlobalSettings = { sensitivity: 2.5 };

// --- GLOBALS ---
let scene, camera, renderer, world;
let dolly, playerBody;
let controllers = { left: null, right: null };
let raycaster, menuSystem;
let enemies = [], kekkaiList = [], items = [];
let playerSystem, gameSystem;

const els = {
  msg: document.getElementById('flashMsg'),
  wVal: document.getElementById('waveVal'), kVal: document.getElementById('killVal'), tVal: document.getElementById('targetVal'),
  hpText: document.getElementById('hpText'), hpBar: document.getElementById('hpBar'),
  kekVal: document.getElementById('kekVal'), distLabel: document.getElementById('distLabel'),
  mobileUI: document.getElementById('mobileUI'), reticle: document.getElementById('centerReticle')
};

// ==========================================
// UTILS
// ==========================================
function updateHUD(){ els.wVal.textContent=gameSystem?gameSystem.wave:1; els.kVal.textContent=gameSystem?gameSystem.kills:0; els.tVal.textContent=gameSystem?gameSystem.req:3; if(els.kekVal)els.kekVal.textContent=kekkaiList.length;}
function showMsg(t,c){els.msg.textContent=t; els.msg.style.color=c; els.msg.style.opacity=1; setTimeout(()=>els.msg.style.opacity=0,800);}
function spawnText(s,p,c){
    const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
    const ctx = cvs.getContext('2d'); ctx.font = "bold 48px sans-serif"; ctx.fillStyle = c; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(s, 32, 32);
    const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cvs), transparent: true }));
    sp.position.copy(p); sp.scale.set(3, 3, 3); scene.add(sp);
    let f = 0; const a = () => { f += 0.03; sp.position.y += 0.05; sp.material.opacity = 1 - f; if (f < 1) requestAnimationFrame(a); else { scene.remove(sp); sp.material.map.dispose(); } }; a();
}
function spawnParticle(p,n,c){
    const g=new THREE.BoxGeometry(0.2,0.2,0.2), m=new THREE.MeshBasicMaterial({color:c});
    for(let i=0;i<n;i++){ const o=new THREE.Mesh(g,m); o.position.copy(p).add(new THREE.Vector3((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2)); scene.add(o);
    const a=()=>{o.scale.multiplyScalar(0.9); if(o.scale.x>0.05)requestAnimationFrame(a); else scene.remove(o);}; a(); }
}

// ==========================================
// SYSTEMS
// ==========================================

class MobileInputStrategy {
  constructor(domElement) {
    this.domElement = domElement;
    this.stickId=null; this.stickStart={x:0,y:0};
    this.lookId=null; this.lastLook={x:0,y:0};
    this.tapTime=0; this.tapPos={x:0,y:0};
    this.activeDrawId=null; this.drawStart={x:0,y:0};
    this.setupListeners();
  }
  setupListeners() {
    const s = document.getElementById('stickZone');
    const k = document.getElementById('stickKnob');
    const rd = this.domElement;
    
    s.addEventListener('touchstart',e=>{
       e.preventDefault(); if(this.stickId!==null)return;
       const t=e.changedTouches[0]; this.stickId=t.identifier;
       const r=s.getBoundingClientRect(); this.stickStart={x:r.left+r.width/2, y:r.top+r.height/2};
       this.tapTime=Date.now(); this.tapPos={x:t.clientX,y:t.clientY};
       this.moveStick(t.clientX,t.clientY,s,k);
    },{passive:false});
    s.addEventListener('touchmove',e=>{
       e.preventDefault();
       for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===this.stickId) this.moveStick(e.changedTouches[i].clientX,e.changedTouches[i].clientY,s,k);
    },{passive:false});
    s.addEventListener('touchend',e=>{
       for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===this.stickId){
          if(Date.now()-this.tapTime<200 && Math.hypot(e.changedTouches[i].clientX-this.tapPos.x,e.changedTouches[i].clientY-this.tapPos.y)<15) playerSystem.inputState.actions.jump=true;
          this.stickId=null; playerSystem.inputState.move={x:0,y:0}; k.style.transform='translate(-50%,-50%)';
       }
    });

    rd.addEventListener('touchstart',e=>{
       for(let i=0;i<e.changedTouches.length;i++) if(this.lookId===null && e.changedTouches[i].target===rd){ this.lookId=e.changedTouches[i].identifier; this.lastLook={x:e.changedTouches[i].clientX,y:e.changedTouches[i].clientY}; }
    },{passive:false});
    rd.addEventListener('touchmove',e=>{
       if(this.lookId===null)return;
       for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===this.lookId){
           const t=e.changedTouches[i]; playerSystem.rotateCamera((t.clientX-this.lastLook.x)*0.004, (t.clientY-this.lastLook.y)*0.004); this.lastLook={x:t.clientX,y:t.clientY};
       }
    },{passive:false});
    rd.addEventListener('touchend',e=>{ for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===this.lookId) this.lookId=null; });

    document.getElementById('btnDown').addEventListener('touchstart',e=>{e.preventDefault(); playerSystem.inputState.actions.jump=true;});
    document.getElementById('btnUp').addEventListener('touchstart',e=>{e.preventDefault(); playerSystem.inputState.actions.dist=true;});
    document.getElementById('modeSwitch').addEventListener('touchstart',e=>{e.preventDefault(); playerSystem.toggleMode();});

    let actId=null, actStart={x:0,y:0};
    document.getElementById('btnLeft').addEventListener('touchstart',e=>{e.preventDefault(); if(actId!==null)return; const t=e.changedTouches[0]; actId=t.identifier; actStart={x:t.clientX,y:t.clientY};});
    document.getElementById('btnLeft').addEventListener('touchend',e=>{
       e.preventDefault();
       for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===actId){
           if(Math.hypot(e.changedTouches[i].clientX-actStart.x, e.changedTouches[i].clientY-actStart.y)<20) playerSystem.inputState.actions.metsu=true;
           else playerSystem.inputState.actions.kai=true;
           actId=null;
       }
    });

    const btnD = document.getElementById('btnRight');
    btnD.addEventListener('touchstart',e=>{
       e.preventDefault(); if(this.activeDrawId!==null)return;
       const t=e.changedTouches[0]; this.activeDrawId=t.identifier; this.drawStart={x:t.clientX,y:t.clientY};
       playerSystem.inputState.actions.drawType = playerSystem.isPhysMode ? 'physical' : 'ghost'; 
       btnD.classList.add('drawing');
    });
    btnD.addEventListener('touchmove',e=>{
       e.preventDefault();
       for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===this.activeDrawId){
           const t=e.changedTouches[i];
           playerSystem.inputState.drawDelta = { x: Math.abs(t.clientX-this.drawStart.x)*0.06, y: (this.drawStart.y-t.clientY)*0.06 };
       }
    });
    btnD.addEventListener('touchend',e=>{
       for(let i=0;i<e.changedTouches.length;i++) if(e.changedTouches[i].identifier===this.activeDrawId){
           this.activeDrawId=null; playerSystem.inputState.actions.drawType=null; btnD.classList.remove('drawing');
       }
    });
  }
  moveStick(cx,cy,s,k){
     let dx=cx-this.stickStart.x, dy=cy-this.stickStart.y;
     const d=Math.hypot(dx,dy), max=(s.offsetWidth/2)*0.8;
     if(d>max){dx*=max/d; dy*=max/d;}
     playerSystem.inputState.move={x:dx/max, y:dy/max};
     k.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  }
  dispose(){}
}

class VRInputStrategy {
  constructor() {
    this.lastState = { jump:false, dist:false, metsu:false, kai:false, menu:false, leftGrip:false, rightGrip:false };
    this.gripStartPos = { left: new THREE.Vector3(), right: new THREE.Vector3() };
  }
  updateState(state, dt) {
    const s = renderer.xr.getSession(); if(!s) return;
    state.actions.jump=false; state.actions.dist=false; state.actions.metsu=false; state.actions.kai=false; state.actions.menu=false;

    if(menuSystem && menuSystem.isOpen) { state.move={x:0,y:0}; }

    for(const src of s.inputSources){
      if(!src.gamepad) continue;
      const gp = src.gamepad;
      const hand = src.handedness;
      const isTrig = gp.buttons[0]?.pressed;
      const isGrip = gp.buttons[1]?.pressed;
      const isBtnA = gp.buttons[4]?.pressed; 
      const isBtnB = gp.buttons[5]?.pressed; 

      if(hand === 'left'){
         if(!menuSystem.isOpen) { state.move.x = gp.axes[2]; state.move.y = gp.axes[3]; }
         if((isBtnA||isBtnB) && !this.lastState.menu) state.actions.menu=true;
         this.lastState.menu=(isBtnA||isBtnB);

         // LEFT GRIP (PHYSICAL)
         if(isGrip && !this.lastState.leftGrip) {
             state.actions.drawType = 'physical';
             this.gripStartPos.left.copy(controllers.left.position);
         } else if(!isGrip && this.lastState.leftGrip && state.actions.drawType==='physical') {
             state.actions.drawType = null; 
         }
         
         if(state.actions.drawType==='physical') {
             const cp = controllers.left.position;
             const dy = Math.max(0, cp.y - this.gripStartPos.left.y);
             const dPlane = Math.max(Math.abs(cp.x - this.gripStartPos.left.x), Math.abs(cp.z - this.gripStartPos.left.z));
             state.drawDelta = { x: dPlane * GlobalSettings.sensitivity, y: dy * GlobalSettings.sensitivity };
         }
         this.lastState.leftGrip = isGrip;

         // LEFT TRIGGER (KAI)
         if(isTrig && !this.lastState.kai) state.actions.kai = true;
         this.lastState.kai = isTrig;
      }
      
      if(hand === 'right'){
         if(!menuSystem.isOpen) state.look.x = gp.axes[2];
         if(isBtnA && !this.lastState.jump) state.actions.jump=true; this.lastState.jump=isBtnA;
         if(isBtnB && !this.lastState.dist) state.actions.dist=true; this.lastState.dist=isBtnB;

         // RIGHT GRIP (GHOST)
         if(isGrip && !this.lastState.rightGrip) {
             state.actions.drawType = 'ghost';
             this.gripStartPos.right.copy(controllers.right.position);
         } else if(!isGrip && this.lastState.rightGrip && state.actions.drawType==='ghost') {
             state.actions.drawType = null; 
         }
         if(state.actions.drawType==='ghost') {
             const cp = controllers.right.position;
             const dy = Math.max(0, cp.y - this.gripStartPos.right.y);
             const dPlane = Math.max(Math.abs(cp.x - this.gripStartPos.right.x), Math.abs(cp.z - this.gripStartPos.right.z));
             state.drawDelta = { x: dPlane * GlobalSettings.sensitivity, y: dy * GlobalSettings.sensitivity };
         }
         this.lastState.rightGrip = isGrip;

         // RIGHT TRIGGER (METSU)
         if(isTrig && !this.lastState.metsu) state.actions.metsu = true;
         this.lastState.metsu = isTrig;
      }
    }
  }
  dispose(){}
}

class InputManager {
  constructor(domElement) {
    this.domElement = domElement;
    this.strategy = new MobileInputStrategy(this.domElement);
    this.state = {
      move: { x: 0, y: 0 },
      look: { x: 0, y: 0 },
      actions: { jump: false, dist: false, metsu: false, kai: false, drawType: null, menu: false },
      drawDelta: { x: 0, y: 0 },
      isVR: false
    };
  }
  setStrategy(strategy) {
    if(this.strategy) this.strategy.dispose();
    this.strategy = strategy;
    this.state.isVR = (strategy instanceof VRInputStrategy);
    if(this.state.isVR) { els.mobileUI.style.display = 'none'; els.reticle.style.display = 'none'; } 
    else { els.mobileUI.style.display = 'block'; els.reticle.style.display = 'block'; }
  }
  update(dt) {
    if(this.strategy) this.strategy.updateState(this.state, dt);
    return this.state;
  }
}

class KekkaiSystem {
  startDrawing(position, rotation, type) {
    const isPhysical = (type === 'physical');
    const g = new THREE.BoxGeometry(1, 1, 1);
    const col = isPhysical ? 0xffff00 : CFG.colors.ghost;
    const m = new THREE.Mesh(g, new THREE.MeshPhongMaterial({ color: col, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
    m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff }))); 
    m.position.copy(position); m.rotation.y = rotation; scene.add(m);

    const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek') });
    b.position.copy(position);
    b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rotation);

    if(isPhysical) {
        this.updateHollowShapes(b, 1, 1, 1);
        world.addBody(b);
    }
    return { body: b, mesh: m, startP: position.clone(), startR: rotation, currentS: {x:1, y:1, z:1}, type: type, inWorld: isPhysical };
  }
  updateDrawing(k, dx, dy) {
    if(!k) return;
    const sx = 1.0 + Math.max(0, dx); const sy = 1.0 + Math.max(0, dy); const sz = sx; 
    k.currentS = { x: sx, y: sy, z: sz }; k.mesh.scale.set(sx, sy, sz);
    const newY = k.startP.y + (sy - 1.0) / 2;
    k.mesh.position.y = newY; k.body.position.y = newY;
    if(k.inWorld) { this.updateHollowShapes(k.body, sx, sy, sz); }
  }
  finalize(k) {
    if(!k) return;
    const bbox = new THREE.Box3().setFromObject(k.mesh);
    const trapped = [];
    enemies.forEach(e => { if(bbox.containsPoint(e.mesh.position)) trapped.push(e); });
    k.trapped = trapped;
    if(!k.inWorld) { world.addBody(k.body); k.inWorld = true; }
    this.updateHollowShapes(k.body, k.currentS.x, k.currentS.y, k.currentS.z);
    k.mesh.material.color.setHex(CFG.colors.kekkai); k.mesh.material.opacity = 0.3;
    spawnText(k.type === 'physical' ? "顕" : "結", k.mesh.position, "#0ff");
    kekkaiList.push(k); updateHUD();
  }
  updateHollowShapes(body, w, h, d) {
    while(body.shapes.length > 0){ body.removeShape(body.shapes[0]); }
    const t = 0.5; const hx=w/2, hy=h/2, hz=d/2;
    body.addShape(new CANNON.Box(new CANNON.Vec3(hx, t/2, hz)), new CANNON.Vec3(0, hy, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(hx, t/2, hz)), new CANNON.Vec3(0, -hy, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(t/2, hy, hz)), new CANNON.Vec3(hx, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(t/2, hy, hz)), new CANNON.Vec3(-hx, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, t/2)), new CANNON.Vec3(0, 0, hz));
    body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, t/2)), new CANNON.Vec3(0, 0, -hz));
  }
}

class VRMenuSystem {
  constructor() {
    this.isOpen=false; this.mesh=null;
    this.canvas=document.createElement('canvas'); this.canvas.width=512; this.canvas.height=512;
    this.ctx=this.canvas.getContext('2d'); this.texture=new THREE.CanvasTexture(this.canvas);
    this.initMesh(); this.draw();
  }
  initMesh() {
    this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshBasicMaterial({ map:this.texture, transparent:true, side:THREE.DoubleSide, depthTest:false }));
    this.mesh.renderOrder=9999; this.mesh.visible=false; scene.add(this.mesh);
  }
  toggle() {
    this.isOpen=!this.isOpen; this.mesh.visible=this.isOpen;
    if(this.isOpen) {
        const p = dolly.position.clone(); const d = new THREE.Vector3(); camera.getWorldDirection(d); d.y=0; d.normalize();
        this.mesh.position.copy(p).add(new THREE.Vector3(0,1.6,0)).add(d.multiplyScalar(1.5));
        this.mesh.lookAt(p.x,1.6,p.z); this.mesh.rotation.y+=Math.PI; controllers.right.add(raycaster.line);
    } else { controllers.right.remove(raycaster.line); }
  }
  draw() {
    const c=this.ctx; c.fillStyle='rgba(0,20,40,0.9)'; c.fillRect(0,0,512,512); c.strokeStyle='#00ffff'; c.lineWidth=10; c.strokeRect(5,5,502,502);
    c.font='bold 50px sans-serif'; c.fillStyle='#ffeb3b'; c.textAlign='center'; c.fillText("VR SETTINGS",256,70);
    c.font='30px sans-serif'; c.fillStyle='#fff'; c.textAlign='left'; c.fillText(`感度: ${GlobalSettings.sensitivity.toFixed(1)}`,50,150);
    c.fillStyle='#555'; c.fillRect(50,180,400,10);
    const r=(GlobalSettings.sensitivity-1)/9; c.fillStyle='#00ffff'; c.beginPath(); c.arc(50+400*r,185,20,0,Math.PI*2); c.fill();
    c.fillStyle='#ff4444'; c.fillRect(156,430,200,60); c.fillStyle='#fff'; c.textAlign='center'; c.fillText("CLOSE",256,470);
    this.texture.needsUpdate=true;
  }
  updateInteraction() {
    if(!this.isOpen)return;
    const m=new THREE.Matrix4().identity().extractRotation(controllers.right.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controllers.right.matrixWorld);
    raycaster.ray.direction.set(0,0,-1).applyMatrix4(m);
    const hits=raycaster.intersectObject(this.mesh);
    if(hits.length>0 && controllers.right.userData.isTriggerPressed) {
        const y=(1-hits[0].uv.y)*512; const x=hits[0].uv.x*512;
        if(y>150&&y<220&&x>30&&x<480){ GlobalSettings.sensitivity=1.0+Math.max(0,Math.min(1,(x-50)/400))*9.0; this.draw(); }
        if(y>430&&y<490&&x>156&&x<356) this.toggle();
    }
  }
}

class PlayerSystem {
  constructor(domElement) {
    this.hp=CFG.player.maxHp; this.dist=CFG.dist.near; this.isPhysMode=false;
    this.aimMarker=null; this.camAngle={yaw:0,pitch:0};
    this.inputManager = new InputManager(domElement); 
    this.inputState = this.inputManager.state;
    this.kekkaiSystem = new KekkaiSystem(); this.activeKekkai=null;
    this.initPhysics(); this.initVisuals();
  }
  initPhysics() {
    const mPly=new CANNON.Material('ply');
    playerBody=new CANNON.Body({mass:70, shape:new CANNON.Sphere(0.6), material:mPly, fixedRotation:true, linearDamping:0.9});
    playerBody.position.set(0,5,30); world.addBody(playerBody);
    playerBody.addEventListener('collide',e=>{
       if(e.body?.material?.name==='ene'){
         const v=e.contact.getImpactVelocityAlongNormal();
         if(Math.abs(v)>2){ this.takeDamage(Math.floor(Math.abs(v)*2)); const n=new CANNON.Vec3(); e.contact.ni.negate(n); playerBody.applyImpulse(n.scale(50*Math.abs(v)), playerBody.position); }
       }
    });
  }
  initVisuals() {
    dolly=new THREE.Group(); dolly.add(camera); scene.add(dolly);
    this.aimMarker=new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshBasicMaterial({color:CFG.colors.marker,transparent:true,opacity:0.7,depthTest:false}));
    this.aimMarker.renderOrder=999; scene.add(this.aimMarker);
  }
  rotateCamera(dx,dy) { this.camAngle.yaw-=dx; this.camAngle.pitch=Math.max(-1.5,Math.min(1.5,this.camAngle.pitch-dy)); }
  toggleMode() { 
      this.isPhysMode=!this.isPhysMode; 
      const b=document.getElementById('modeSwitch'); const bd=document.getElementById('btnRight');
      b.textContent=this.isPhysMode?"モード: 顕現":"モード: 幽体"; b.className=this.isPhysMode?"phys":"ghost";
      bd.style.background=this.isPhysMode?"linear-gradient(135deg,#FFD700,#FF8C00)":"linear-gradient(135deg,#03a9f4,#0288d1)";
      showMsg(this.isPhysMode?"物理顕現モード":"幽体結界モード","#fff");
  }
  takeDamage(v) { this.hp=Math.max(0,this.hp-v); els.hpText.textContent=this.hp; els.hpBar.style.width=(this.hp)+"%"; if(this.hp<=0) showMsg("GAME OVER","#f00"); }
  heal(v){ this.hp=Math.min(100,this.hp+v); els.hpText.textContent=this.hp; els.hpBar.style.width=(this.hp)+"%"; showMsg("RECOVER!","#0f0"); }

  update(dt) {
    const inp = this.inputManager.update(dt);
    if(inp.actions.menu) { menuSystem.toggle(); inp.actions.menu=false; }
    let mv = new THREE.Vector3(inp.move.x, 0, inp.move.y);
    if(inp.isVR) {
        const d=new THREE.Vector3(); camera.getWorldDirection(d); d.y=0; d.normalize();
        const r=new THREE.Vector3().crossVectors(d,new THREE.Vector3(0,1,0));
        mv = r.multiplyScalar(inp.move.x).add(d.multiplyScalar(-inp.move.y));
        if(Math.abs(inp.look.x)>0.5) { if(!this.snapW) { dolly.rotation.y-=Math.sign(inp.look.x)*Math.PI/4; this.snapW=true; } } else this.snapW=false;
        dolly.position.copy(playerBody.position);
    } else {
        mv.applyAxisAngle(new THREE.Vector3(0,1,0), this.camAngle.yaw);
        camera.rotation.x=this.camAngle.pitch; dolly.rotation.y=this.camAngle.yaw;
        dolly.position.copy(playerBody.position).add(new THREE.Vector3(0,CFG.player.height,0));
    }
    playerBody.velocity.x=mv.x*CFG.player.speed; playerBody.velocity.z=mv.z*CFG.player.speed;
    if(inp.actions.jump && Math.abs(playerBody.velocity.y)<1) playerBody.velocity.y=CFG.player.jump;
    if(inp.actions.dist) { this.dist=(this.dist===8.0?20.0:8.0); els.distLabel.textContent=(this.dist===8.0?"近":"遠"); inp.actions.dist=false; }
    
    if(inp.actions.drawType) {
        if(!this.activeKekkai) {
             if(kekkaiList.length>=CFG.kekkai.max) showMsg("上限到達","#f44");
             else {
                 let rot = this.camAngle.yaw;
                 if(inp.isVR) { const e=new THREE.Euler().setFromQuaternion(camera.quaternion,'YXZ'); rot=e.y; }
                 this.activeKekkai = this.kekkaiSystem.startDrawing(this.aimMarker.position, rot, inp.actions.drawType);
             }
        } else { this.kekkaiSystem.updateDrawing(this.activeKekkai, inp.drawDelta.x, inp.drawDelta.y); }
    } else { if(this.activeKekkai) { this.kekkaiSystem.finalize(this.activeKekkai); this.activeKekkai=null; } }

    if(inp.actions.metsu && !this.activeKekkai) { this.actionMetsu(); inp.actions.metsu=false; }
    if(inp.actions.kai) { this.actionKai(); inp.actions.kai=false; }

    if(this.aimMarker){
        let o, d=new THREE.Vector3();
        if(inp.isVR && controllers.right) { o=controllers.right.position.clone(); d.set(0,0,-1).applyMatrix4(new THREE.Matrix4().extractRotation(controllers.right.matrixWorld)); }
        else { const e=new THREE.Euler(this.camAngle.pitch,this.camAngle.yaw,0,'YXZ'); d.set(0,0,-1).applyEuler(e); o=dolly.position.clone(); }
        const p=o.add(d.multiplyScalar(this.dist)); p.y=Math.max(0.5,p.y); this.aimMarker.position.copy(p);
    }
  }

  actionMetsu() {
    let t=null, min=999;
    kekkaiList.forEach(k=>{ const d=playerBody.position.distanceTo(k.body.position); if(d<min){min=d; t=k;} });
    if(!t||t.shrinking){ showMsg("対象なし","#888"); return; }
    showMsg("滅！","#f24"); spawnText("滅",t.mesh.position,"#f24"); t.shrinking=true; t.mesh.material.color.setHex(0xff0044);
    let sc=1.0; const iS=t.mesh.scale.clone();
    const loop=()=>{
      if(!kekkaiList.includes(t))return;
      sc-=0.05; t.mesh.scale.set(iS.x*sc, iS.y*sc, iS.z*sc);
      this.kekkaiSystem.updateHollowShapes(t.body, iS.x*sc, iS.y*sc, iS.z*sc);
      if(t.trapped) t.trapped.forEach(e=>{
         if(enemies.includes(e)){ 
             e.body.applyForce(t.body.position.vsub(e.body.position).normalize().scale(500), e.body.position);
             if(sc<0.5 && gameSystem){ if(e.isGiant)e.hp=0; gameSystem.killEnemy(e); }
         }
      });
      if(sc<=0.1) { this.kekkaiSystem.updateHollowShapes(t.body,0,0,0); scene.remove(t.mesh); world.removeBody(t.body); kekkaiList=kekkaiList.filter(o=>o!==t); updateHUD(); spawnParticle(t.mesh.position,30,0xffaa00); }
      else requestAnimationFrame(loop);
    }; loop();
  }
  actionKai() {
      const t=kekkaiList.pop();
      if(t){ showMsg("解","#4f8"); spawnText("解",t.mesh.position,"#4f8"); scene.remove(t.mesh); world.removeBody(t.body); updateHUD(); }
      else showMsg("結界なし","#888");
  }
}

class GameSystem {
  constructor() {
    this.wave=1; this.kills=0; this.req=3; this.next=0; this.vip=null;
    this.mE=new CANNON.Material('e'); this.mK=new CANNON.Material('k');
    const mP=playerBody.material;
    world.addContactMaterial(new CANNON.ContactMaterial(mP,this.mE,{friction:0.5,restitution:0.5}));
    world.addContactMaterial(new CANNON.ContactMaterial(this.mK,this.mE,{friction:0.1,restitution:0.8}));
    world.addContactMaterial(new CANNON.ContactMaterial(this.mK,mP,{friction:0.8,restitution:0}));
    this.setupEnv(); for(let i=0;i<3;i++)this.spawn();
  }
  setupEnv() {
    const l=new THREE.DirectionalLight(0xffffee,1.2); l.position.set(-50,100,50); l.castShadow=true; scene.add(l); scene.add(new THREE.AmbientLight(0x555,0.6));
    const g=new THREE.Mesh(new THREE.PlaneGeometry(160,200),new THREE.MeshStandardMaterial({color:CFG.colors.ground})); g.rotation.x=-Math.PI/2; g.receiveShadow=true; scene.add(g);
    const gb=new CANNON.Body({mass:0}); gb.addShape(new CANNON.Plane()); gb.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(gb);
    this.goal=new THREE.Mesh(new THREE.CylinderGeometry(3,3,10,16),new THREE.MeshBasicMaterial({color:0x00ff00,transparent:true,opacity:0.2}));
    this.goal.position.set(0,5,81); this.goal.visible=false; scene.add(this.goal);
  }
  spawn() {
    if(enemies.length>=6+this.wave)return;
    const r=Math.random(), sz=0.6+Math.random()*0.8;
    let x,z,y=20;
    if(r<0.6){x=(Math.random()-.5)*120; z=(Math.random()-.5)*160;} else {x=35; z=(Math.random()-.5)*50; y=10;}
    const b=new CANNON.Body({mass:15*sz, shape:new CANNON.Sphere(sz), material:this.mE, linearDamping:0.4});
    b.position.set(x,y,z); world.addBody(b);
    const m=new THREE.Mesh(new THREE.IcosahedronGeometry(sz),new THREE.MeshStandardMaterial({color:0xff4444}));
    scene.add(m); enemies.push({body:b,mesh:m,isGiant:false}); updateHUD();
  }
  killEnemy(e){
      if(!enemies.includes(e))return;
      enemies=enemies.filter(o=>o!==e); scene.remove(e.mesh); world.removeBody(e.body);
      this.kills++; this.req--; if(this.req<=0){this.wave++; this.req=this.wave*2+4; showMsg("WAVE "+this.wave,"#fe0"); if(this.wave%3===0)this.startVip();}
      updateHUD(); spawnParticle(e.mesh.position,20,0xff0000);
  }
  startVip() {
      if(this.vip)return; showMsg("護衛任務","#0ff"); this.goal.visible=true; document.getElementById('vipBox').style.display='block';
      const b=new CANNON.Body({mass:50, shape:new CANNON.Cylinder(0.5,0.5,1.8,8), fixedRotation:true}); b.position.set(0,5,-30); world.addBody(b);
      const m=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1.8),new THREE.MeshStandardMaterial({color:0x0000ff})); scene.add(m);
      this.vip={body:b,mesh:m,hp:100};
  }
  update(t,dt) {
      if(t>this.next){this.spawn(); this.next=t+3000;}
      enemies.forEach(e=>{
          e.mesh.position.copy(e.body.position); e.mesh.quaternion.copy(e.body.quaternion);
          if(e.body.position.y<-10)this.killEnemy(e);
          const tgt = (this.vip&&this.vip.hp>0)?this.vip.body.position:playerBody.position;
          e.body.applyForce(tgt.vsub(e.body.position).normalize().scale(20), e.body.position);
      });
      if(this.vip){
          this.vip.mesh.position.copy(this.vip.body.position);
          const d=this.vip.body.position.distanceTo(new THREE.Vector3(0,0,81));
          if(d>1) { const v=new THREE.Vector3(0,0,81).sub(this.vip.body.position).normalize().scale(3.5); this.vip.body.velocity.x=v.x; this.vip.body.velocity.z=v.z; }
          else { showMsg("CLEAR!","#0f0"); scene.remove(this.vip.mesh); world.removeBody(this.vip.body); this.vip=null; this.goal.visible=false; document.getElementById('vipBox').style.display='none'; }
      }
  }
}

// ==========================================
// INIT MAIN
// ==========================================
window.onload = function() {
  scene = new THREE.Scene(); scene.background = new THREE.Color(CFG.colors.sky); 
  scene.fog = new THREE.FogExp2(CFG.colors.sky, 0.005);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
  renderer = new THREE.WebGLRenderer({ antialias: true }); 
  renderer.setSize(window.innerWidth, window.innerHeight); 
  renderer.shadowMap.enabled = true; 
  renderer.xr.enabled = true; 
  renderer.xr.setReferenceSpaceType('local-floor');
  document.body.appendChild(renderer.domElement);

  // VR Support Check
  const btn = document.getElementById('vrStartBtn');
  if('xr' in navigator) {
      navigator.xr.isSessionSupported('immersive-vr').then(s=>{ 
          if(s){
              btn.style.display='block'; 
              btn.onclick = startVR;
          }
      });
  }

  function startVR(){ 
      navigator.xr.requestSession('immersive-vr',{
          optionalFeatures:['local-floor','bounded-floor','hand-tracking']
      }).then(onSession).catch(err => {
          console.error(err);
          alert("VR Init Failed: " + err.message);
      }); 
  }
  
  function onSession(s){ 
      s.addEventListener('end',onEnd); 
      renderer.xr.setSession(s); 
      btn.style.display='none'; 
      playerSystem.inputManager.setStrategy(new VRInputStrategy());
      dolly.position.set(0,5,30); 
      playerBody.position.set(0,5,30);
  }
  
  function onEnd(){ 
      playerSystem.inputManager.setStrategy(new MobileInputStrategy(renderer.domElement)); 
      btn.style.display='block'; 
  }

  world = new CANNON.World(); world.gravity.set(0, -30, 0);

  // Initialize all systems
  playerSystem = new PlayerSystem(renderer.domElement);
  gameSystem = new GameSystem();
  menuSystem = new VRMenuSystem();

  raycaster = new THREE.Raycaster();
  raycaster.line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-5)]), new THREE.LineBasicMaterial({color:0xff0000}));

  // Controllers
  const mf = new XRControllerModelFactory();
  for(let i=0; i<2; i++){
     const c = renderer.xr.getController(i);
     const g = renderer.xr.getControllerGrip(i);
     g.add(mf.createControllerModel(g));
     dolly.add(c); dolly.add(g); 
     c.addEventListener('connected', e=>{ 
         const h=e.data.handedness; 
         controllers[h]=c; 
         c.userData.handedness=h; 
     });
     c.addEventListener('selectstart',()=>c.userData.isTriggerPressed=true);
     c.addEventListener('selectend',()=>c.userData.isTriggerPressed=false);
  }

  // Loop
  let lastT=0;
  renderer.setAnimationLoop((t)=>{
      const dt = Math.min((t - lastT) / 1000, 0.1); 
      lastT = t;
      
      world.step(1/60, dt, 3);
      
      if(menuSystem) menuSystem.updateInteraction();
      if(playerSystem) playerSystem.update(dt);
      if(gameSystem) gameSystem.update(t, dt);
      
      renderer.render(scene, camera);
  });
};
</script>
</body>
</html>
