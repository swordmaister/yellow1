<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR — Re:Incarnation</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<meta name="theme-color" content="#87CEEB">
<style>
  html, body { height: 100%; margin: 0; background: #87CEEB; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
  canvas { display: block; width: 100%; height: 100%; outline: none; }
  
  #error-log { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:#ff5555; padding:20px; z-index:9999; white-space:pre-wrap; font-weight:bold; overflow:auto; }
  #damage-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 60%, red 100%); opacity: 0; pointer-events: none; z-index: 50; transition: opacity 0.1s; }

  /* UI Elements */
  .novr-only { transition: opacity 0.5s; }

  #hud { position: fixed; top: 16px; left: 16px; pointer-events: none; z-index: 10; }
  @supports (padding-top: env(safe-area-inset-top)) { #hud { top: calc(env(safe-area-inset-top) + 10px); left: calc(env(safe-area-inset-left) + 16px); } }
  
  .hud-box { background: rgba(0, 30, 60, 0.6); padding: 8px 16px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.4); margin-bottom: 8px; backdrop-filter: blur(4px); min-width: 140px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
  .big-text { font-size: 18px; font-weight: bold; color: #ffeb3b; text-shadow: 1px 1px 2px #000; }
  .sub-text { font-size: 14px; color: #fff; text-shadow: 1px 1px 1px #000; }
  .hp-bar-bg { width: 100%; height: 8px; background: #555; margin-top: 4px; border-radius: 4px; overflow: hidden; }
  .hp-bar-val { width: 100%; height: 100%; background: #0f0; transition: width 0.2s; }

  #msgArea { position: fixed; top: 35%; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
  .flash-msg { font-size: 60px; font-weight: 900; color: #fff; text-shadow: 0 0 20px #f0a, 3px 3px 0 #000; opacity: 0; transition: opacity 0.1s; transform: scale(0.8); }

  /* Mobile Controllers */
  #uiLayer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
  #stickZone { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; pointer-events: auto; margin-bottom: env(safe-area-inset-bottom); margin-left: env(safe-area-inset-left); }
  #padArea { position: absolute; bottom: 30px; right: 30px; width: 180px; height: 180px; pointer-events: none; margin-bottom: env(safe-area-inset-bottom); margin-right: env(safe-area-inset-right); }
  .stick-base { width: 100%; height: 100%; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; position: relative; }
  .stick-knob { width: 60px; height: 60px; background: #fff; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 10px rgba(0,0,0,0.3); pointer-events: none; }
  .btn { position: absolute; width: 65px; height: 65px; z-index: 10; border-radius: 50%; border: 2px solid rgba(255,255,255,0.6); background: rgba(40,50,80,0.8); color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; pointer-events: auto; touch-action: manipulation; transition: transform 0.1s; }
  .btn:active { transform: scale(0.9); background: rgba(60,70,100,0.9); }
  #btnUp { top: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #607d8b, #455a64); }
  #btnDown { bottom: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #9c27b0, #7b1fa2); width: 75px; height: 75px; font-size: 16px; }
  #btnLeft { top: 50%; left: 0; transform: translateY(-50%); background: linear-gradient(135deg, #f44336, #c62828); }
  #btnRight { top: 50%; right: 0; transform: translateY(-50%); background: linear-gradient(135deg, #03a9f4, #0288d1); width: 75px; height: 75px; font-size: 18px; }
  #btnRight.drawing { background: #fff; color: #0288d1; transform: translateY(-50%) scale(1.1); }
  #modeSwitch { position: absolute; top: -60px; right: 0; width: 140px; height: 40px; background: rgba(0,0,0,0.6); border: 2px solid #fff; border-radius: 20px; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:bold; pointer-events:auto; transition: background 0.3s; }
  #modeSwitch.phys { background: linear-gradient(90deg, #FFD700, #FF8C00); color:#000; border-color:#fff; }
  #modeSwitch.ghost { background: linear-gradient(90deg, #00bfff, #0000ff); color:#fff; border-color:#00ffff; }

  @media (orientation: portrait) {
    #stickZone { width: 110px; height: 110px; bottom: 20px; left: 10px; } .stick-knob { width: 45px; height: 45px; }
    #padArea { width: 150px; height: 150px; bottom: 20px; right: 10px; } .btn { width: 50px; height: 50px; font-size: 10px; }
    #btnDown, #btnRight { width: 55px; height: 55px; } #modeSwitch { top: -50px; width: 120px; height: 35px; font-size: 11px; }
  }
  @media (max-width: 360px) { #stickZone { width: 90px; height: 90px; bottom: 15px; left: 5px; } #padArea { width: 130px; height: 130px; bottom: 15px; right: 5px; } .btn { width: 45px; height: 45px; } }

  #centerReticle { position: fixed; top: 50%; left: 50%; width: 6px; height: 6px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: 1px solid rgba(0,0,0,0.5); }
  #vrBtn { position: fixed; top: 10px; right: 10px; padding: 12px 24px; background: rgba(0,0,0,0.8); border: 2px solid #0f0; color: #0f0; border-radius: 8px; z-index: 200; pointer-events: auto; font-weight: bold; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #0f0; }
</style>
<script>
  window.onerror = function(msg, url, line) {
    const box = document.getElementById('error-log'); box.style.display = 'block';
    box.textContent += "Error: " + msg + "\nLine: " + line + "\n"; return false;
  };
</script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="error-log"></div><div id="damage-overlay"></div>
<div id="hud" class="novr-only"><div class="hud-box"><span class="big-text" id="waveVal">WAVE 1</span><br><span class="sub-text">撃破: <span id="killVal">0</span> / 残: <span id="targetVal" style="color:#f88;">3</span></span></div><div class="hud-box"><span class="sub-text">HP: <span id="hpText">100</span></span><div class="hp-bar-bg"><div id="hpBar" class="hp-bar-val"></div></div></div><div class="hud-box" id="vipBox" style="display:none; border-color:#0f0;"><span class="sub-text" style="color:#0f0;">護衛対象 (脱出中)</span><div class="hp-bar-bg"><div id="vipHpBar" class="hp-bar-val" style="background:#0ff;"></div></div></div></div>
<div id="msgArea"><div id="flashMsg" class="flash-msg"></div></div><div id="centerReticle" class="novr-only"></div><button id="vrBtn">VR START</button>
<div id="uiLayer" class="novr-only"><div id="stickZone"><div class="stick-base"><div id="stickKnob" class="stick-knob"></div></div></div><div id="padArea"><div id="modeSwitch" class="ghost">モード: 幽体</div><div id="btnUp" class="btn">距離<br><span id="distLabel" style="color:#fe0">近</span></div><div id="btnLeft" class="btn">滅<br><span style="font-size:10px">⇔解</span></div><div id="btnRight" class="btn">結<br><span style="font-size:10px">Hold</span></div><div id="btnDown" class="btn">跳</div></div></div>

<script type="module">
import * as THREE from 'three'; 
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js'; 
import * as CANNON from 'cannon-es';

// --------------------------------------------------
// 1. CONFIG
// --------------------------------------------------
const CFG = {
  colors: {
    sky: 0x87CEEB, ground: 0xC2B280, 
    kekkai: 0xffff00, ghost: 0x00ffff, 
    drawPhys: 0xffff00, drawGhost: 0x00ffff,
    marker: 0xff0000,
    wall: 0xa0a0a0, building: 0xf0f0f0, pool: 0x88cccc,
    enemy: 0xff4444, giant: 0x880000, item: 0x00ff00, vip: 0x0000ff,
    wood: 0x8B4513, leaf: 0x228B22, iron: 0x333333, concrete: 0xaaaaaa
  },
  player: { speed: 12.0, jump: 22.0, height: 1.7, maxHp: 100 },
  kekkai: { max: 10, sensitivity: 15.0 }, 
  dist: { near: 8.0, far: 20.0 },
  field: { width: 120, depth: 160 }
};

// --------------------------------------------------
// 2. GLOBALS
// --------------------------------------------------
let scene, camera, renderer, world;
let playerBody, playerGroup;
let enemies = [], kekkaiList = [], items = [], vip = null;
let gameState = { wave: 1, kills: 0, req: 3, nextSpawn: 0, playerHp: 100, isVipMode: false };
let currentDist = CFG.dist.near, aimMarker, isPhysMode = false;
let controllers = [], controllerGrips = [], vrHudMesh, vrHudCtx, vipGoalMesh = null;
let currentSession = null, lastT = 0;

// VR State - Updated for new specs
let vrState = {
  left: { 
    drawing: false, 
    startPos: new THREE.Vector3(), 
    mesh: null, 
    body: null, // Physics body for dynamic physical barrier
    triggerHeld: false 
  },
  right: { 
    drawing: false, 
    startPos: new THREE.Vector3(), 
    mesh: null, 
    triggerHeld: false, 
    bBtnHeld: false,
    snapTurn: false 
  },
  barrierOrigin: new THREE.Vector3()
};

let input = { x: 0, y: 0 }, camAngle = { yaw: 0, pitch: 0 };
let drawId = null, drawState = { active: false, startX: 0, startY: 0, ghost: null }, activePhysKekkai = null;
let stickId = null, stickStart = { x: 0, y: 0 }, tapTime = 0, tapPos = { x: 0, y: 0 };
let actId = null, actStartPos = { x: 0, y: 0 }, lookId = null, lastLook = { x: 0, y: 0 };

const els = { stick: document.getElementById('stickZone'), knob: document.getElementById('stickKnob'), msg: document.getElementById('flashMsg'), btnDist: document.getElementById('btnUp'), btnJump: document.getElementById('btnDown'), btnAct: document.getElementById('btnLeft'), btnDraw: document.getElementById('btnRight'), modeBtn: document.getElementById('modeSwitch'), distLabel: document.getElementById('distLabel'), wVal: document.getElementById('waveVal'), kVal: document.getElementById('killVal'), tVal: document.getElementById('targetVal'), hpText: document.getElementById('hpText'), hpBar: document.getElementById('hpBar'), dmgOverlay: document.getElementById('damage-overlay'), vipBox: document.getElementById('vipBox'), vipHpBar: document.getElementById('vipHpBar'), novr: document.querySelectorAll('.novr-only') };

// --------------------------------------------------
// 3. HELPER FUNCTIONS
// --------------------------------------------------
function showMsg(t, c) { 
  els.msg.textContent = t; els.msg.style.color = c; els.msg.style.opacity = 1; 
  setTimeout(() => els.msg.style.opacity = 0, 300); 
}
function spawnText(s, p, c) { 
  const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 64; 
  const ctx = cvs.getContext('2d'); ctx.font = "bold 48px sans-serif"; ctx.fillStyle = c; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(s, 64, 32); 
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cvs), transparent: true })); 
  sp.position.copy(p); sp.scale.set(3, 1.5, 3); scene.add(sp); 
  let f = 0; 
  const a = () => { f += 0.15; sp.position.y += 0.05; sp.material.opacity = 1 - f; if (f < 1) requestAnimationFrame(a); else { scene.remove(sp); sp.material.map.dispose(); } }; 
  a(); 
}
function spawnParticle(p, n, c) { 
  const g = new THREE.BoxGeometry(0.25, 0.25, 0.25), m = new THREE.MeshBasicMaterial({ color: c }); 
  for (let i = 0; i < n; i++) { 
    const me = new THREE.Mesh(g, m); me.position.copy(p).add(new THREE.Vector3((Math.random() - .5) * 2, (Math.random() - .5) * 2, (Math.random() - .5) * 2)); scene.add(me); 
    const v = new THREE.Vector3(Math.random() - .5, Math.random() - .5, Math.random() - .5).multiplyScalar(1.5); 
    const a = () => { me.position.add(v); me.scale.multiplyScalar(0.92); if (me.scale.x > 0.05) requestAnimationFrame(a); else scene.remove(me); }; 
    a(); 
  } 
}
function safeRemoveMesh(mesh) { 
  if(!mesh) return; scene.remove(mesh); 
  if(mesh.geometry) mesh.geometry.dispose(); 
  if(mesh.material) { if(Array.isArray(mesh.material)) mesh.material.forEach(m => m.dispose()); else mesh.material.dispose(); } 
  if(mesh.children) { mesh.children.forEach(c => { if(c.geometry) c.geometry.dispose(); if(c.material) c.material.dispose(); }); } 
}
function updateHUD() { 
  if (renderer.xr.isPresenting && vrHudCtx) { 
    const ctx = vrHudCtx; ctx.clearRect(0, 0, 512, 128); 
    ctx.fillStyle = "rgba(0, 20, 40, 0.6)"; ctx.fillRect(0,0,512,128); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(2,2,508,124); 
    ctx.font = "bold 30px sans-serif"; ctx.fillStyle = "#ffeb3b"; ctx.fillText(`WAVE ${gameState.wave}`, 20, 40); 
    ctx.fillStyle = "#fff"; ctx.font = "24px sans-serif"; ctx.fillText(`撃破: ${gameState.kills} / 残: ${gameState.req}`, 20, 80); 
    ctx.fillStyle = gameState.playerHp < 30 ? "#f55" : "#0f0"; ctx.fillText(`HP: ${gameState.playerHp}`, 300, 40); 
    ctx.fillStyle = "#555"; ctx.fillRect(300, 50, 180, 20); ctx.fillStyle = gameState.playerHp < 30 ? "#f00" : "#0f0"; ctx.fillRect(300, 50, 180 * (gameState.playerHp / CFG.player.maxHp), 20); 
    if (gameState.isVipMode && vip) { ctx.fillStyle = "#0ff"; ctx.fillText(`護衛対象: ${vip.hp}%`, 300, 100); } 
    vrHudMesh.material.map.needsUpdate = true; 
  } else { 
    els.wVal.textContent = gameState.wave; els.kVal.textContent = gameState.kills; els.tVal.textContent = gameState.req; 
  } 
}
function takeDamage(val) { 
  gameState.playerHp = Math.max(0, gameState.playerHp - val); els.hpText.textContent = gameState.playerHp; 
  els.hpBar.style.width = (gameState.playerHp / CFG.player.maxHp * 100) + "%"; els.hpBar.style.backgroundColor = gameState.playerHp < 30 ? "#f00" : "#0f0"; 
  els.dmgOverlay.style.opacity = 0.5; setTimeout(() => els.dmgOverlay.style.opacity = 0, 150); 
  if (gameState.playerHp <= 0) showMsg("GAME OVER", "#f00"); 
}
function healPlayer(val) { gameState.playerHp = Math.min(CFG.player.maxHp, gameState.playerHp + val); els.hpText.textContent = gameState.playerHp; els.hpBar.style.width = (gameState.playerHp / CFG.player.maxHp * 100) + "%"; showMsg("RECOVER!", "#0f0"); }

function removeKekkai(k) { safeRemoveMesh(k.mesh); if(k.body) world.removeBody(k.body); kekkaiList = kekkaiList.filter(o => o !== k); updateHUD(); }

function createKekkai(p, s, r, isGhost=false) { 
  const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek'), collisionFilterGroup: 1 }); 
  b.position.copy(p); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), r); 
  if (!isGhost) { 
    b.addShape(new CANNON.Box(new CANNON.Vec3(s.x/2, s.y/2, s.z/2))); 
  } else { 
    const t = 0.5; const x = s.x/2, y = s.y/2, z = s.z/2; 
    b.addShape(new CANNON.Box(new CANNON.Vec3(t, y, z)), new CANNON.Vec3(-x, 0, 0)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(t, y, z)), new CANNON.Vec3(x, 0, 0)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, t, z)), new CANNON.Vec3(0, -y, 0)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, t, z)), new CANNON.Vec3(0, y, 0)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, y, t)), new CANNON.Vec3(0, 0, -z)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, y, t)), new CANNON.Vec3(0, 0, z)); 
  } 
  world.addBody(b); 
  const color = isGhost ? CFG.colors.ghost : CFG.colors.kekkai; const g = new THREE.BoxGeometry(s.x, s.y, s.z); 
  const m = new THREE.MeshPhongMaterial({ color: color, transparent: true, opacity: isGhost ? 0.3 : 0.5, side: THREE.DoubleSide }); 
  const mesh = new THREE.Mesh(g, m); 
  mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); 
  mesh.position.copy(p); mesh.rotation.y = r; scene.add(mesh); 
  kekkaiList.push({ body: b, mesh: mesh, shrinking: false, isGhost: isGhost }); 
  spawnText("結", p, isGhost ? "#0ff" : "#ff0"); updateHUD(); 
}

function spawnItem(pos) { 
  const b = new CANNON.Body({ mass: 1, shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), material: new CANNON.Material('item') }); b.position.copy(pos); world.addBody(b); 
  const m = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: CFG.colors.item, wireframe: true })); m.position.copy(pos); scene.add(m); 
  m.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: CFG.colors.item }))); 
  items.push({ body: b, mesh: m }); 
}

function removeEnemy(e) { if (!enemies.includes(e)) return; enemies = enemies.filter(o => o !== e); scene.remove(e.mesh); world.removeBody(e.body); updateHUD(); }

function killEnemy(e) { 
  if (!enemies.includes(e)) return; 
  if (e.isGiant && e.hp > 0) { e.hp--; spawnParticle(e.mesh.position, 10, 0xffaa00); const push = playerBody.position.vsub(e.body.position); push.normalize(); e.body.applyImpulse(push.scale(-500), e.body.position); if (e.hp > 0) return; } 
  removeEnemy(e); spawnParticle(e.mesh.position, 25, 0xff0000); if (Math.random() < 0.3) spawnItem(e.body.position); 
  gameState.kills++; gameState.req--; if (gameState.req <= 0) { gameState.wave++; gameState.req = gameState.wave * 2 + 4; showMsg(`WAVE ${gameState.wave}`, "#fe0"); if (gameState.wave % 3 === 0) startVipMission(); } updateHUD(); 
}

function spawnGiant(x, y, z) { 
  const b = new CANNON.Body({ mass: 100, material: new CANNON.Material('ene'), linearDamping: 0.5, collisionFilterGroup: 4, collisionFilterMask: 1|2|4 }); 
  b.addShape(new CANNON.Sphere(1.5), new CANNON.Vec3(0, 0, 0)); b.addShape(new CANNON.Sphere(0.8), new CANNON.Vec3(0, 2, 0)); b.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 1.5)), new CANNON.Vec3(0, 0.5, 0)); 
  b.position.set(x, y, z); world.addBody(b); b.outsideTimer = 0; 
  const g = new THREE.Group(); const bm = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshStandardMaterial({ color: CFG.colors.giant })); g.add(bm); 
  const hm = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshStandardMaterial({ color: 0x550000 })); hm.position.y = 2; g.add(hm); 
  const am = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 3), new THREE.MeshStandardMaterial({ color: 0x330000 })); am.position.y = 0.5; g.add(am); 
  scene.add(g); enemies.push({ body: b, mesh: g, isGiant: true, hp: 5 }); 
}

function spawnEnemy() { 
  if (enemies.length >= 6 + gameState.wave) return; 
  const r = Math.random(); let x, y, z; const fW = CFG.field.width, fD = CFG.field.depth; 
  if (r < 0.6) { x = (Math.random() - .5) * fW; z = (Math.random() - .5) * fD; y = 20; } 
  else if (r < 0.8) { x = (Math.random() - .5) * (fW - 5); z = (-fD / 2 - 20) + (Math.random() - .5) * 30; y = 35; } 
  else { x = (fW / 2 - 25) + (Math.random() - .5) * 20; z = (Math.random() - .5) * 50; y = 10; } 
  if (Math.random() < 0.2) spawnGiant(x, y, z); 
  else { 
    const sz = 0.6 + Math.random() * 0.8, cl = new THREE.Color().setHSL(Math.random(), 0.8, 0.5), ms = 15 * sz; 
    const b = new CANNON.Body({ mass: ms, shape: new CANNON.Sphere(sz), material: new CANNON.Material('ene'), linearDamping: 0.4, collisionFilterGroup: 4, collisionFilterMask: 1|2|4 }); 
    b.position.set(x, y, z); world.addBody(b); b.outsideTimer = 0; 
    const m = new THREE.Mesh(new THREE.IcosahedronGeometry(sz, 0), new THREE.MeshStandardMaterial({ color: cl, roughness: 0.3 })); 
    scene.add(m); enemies.push({ body: b, mesh: m, isGiant: false }); 
  } 
  updateHUD(); 
}

function actionMetsu() { 
  let t = null, minD = 999; 
  const pPos = renderer.xr.isPresenting ? playerGroup.position : playerBody.position; 
  kekkaiList.forEach(k => { const d = pPos.distanceTo(k.mesh.position); if (d < minD) { minD = d; t = k; } }); 
  if (!t || t.shrinking) { showMsg("対象なし", "#888"); return; } 
  showMsg("滅！", "#f24"); spawnText("滅", t.mesh.position, "#f24"); t.shrinking = true; t.mesh.material.color.setHex(0xff0044); 
  if (t.body) { world.removeBody(t.body); t.body = null; } 
  const bbox = new THREE.Box3().setFromObject(t.mesh); let sc = 1.0; 
  const loop = () => { 
    if (!kekkaiList.includes(t)) return; sc -= 0.05; t.mesh.scale.setScalar(sc); 
    enemies.forEach(e => { if (bbox.containsPoint(e.mesh.position)) { const d = t.mesh.position.clone().sub(e.body.position); e.body.velocity.set(d.x * 5, d.y * 5, d.z * 5); if (sc < 0.4) killEnemy(e); } }); 
    if (sc <= 0.1) { removeKekkai(t); spawnParticle(t.mesh.position, 30, 0xffaa00); } else requestAnimationFrame(loop); 
  }; loop(); 
}

function actionKai() { 
  if (kekkaiList.length > 0) { const t = kekkaiList[kekkaiList.length - 1]; showMsg("解", "#4f8"); spawnText("解", t.mesh.position, "#4f8"); removeKekkai(t); } else { showMsg("結界なし", "#888"); } 
}

function updateAimMarker() { 
  if(!playerGroup || !aimMarker) return; 
  if (renderer.xr.isPresenting) { 
    const cam = renderer.xr.getCamera(); const dir = new THREE.Vector3(); cam.getWorldDirection(dir); 
    aimMarker.position.copy(cam.position).add(dir.multiplyScalar(currentDist)); aimMarker.visible = true; 
  } else { 
    aimMarker.visible = true; const e = new THREE.Euler(camAngle.pitch, camAngle.yaw, 0, 'YXZ'); 
    const d = new THREE.Vector3(0, 0, -1).applyEuler(e); const p = playerGroup.position.clone().add(d.multiplyScalar(currentDist)); 
    p.y = Math.max(0.5, p.y); aimMarker.position.copy(p); 
  } 
}

function startVipMission() { 
  if (vip) return; 
  gameState.isVipMode = true; showMsg("護衛任務開始!", "#0ff"); els.vipBox.style.display = "block"; 
  const b = new CANNON.Body({ mass: 50, shape: new CANNON.Cylinder(0.5, 0.5, 1.8, 8), material: new CANNON.Material('ply'), fixedRotation: true, linearDamping: 0.5, collisionFilterGroup: 2, collisionFilterMask: 1|4 }); 
  b.position.set(0, 5, -CFG.field.depth / 2 + 30); 
  world.addBody(b); 
  const g = new THREE.Group(); g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.8, 16), new THREE.MeshStandardMaterial({ color: CFG.colors.vip }))); 
  const h = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({ color: 0xffcccc })); h.position.y = 1.0; g.add(h); scene.add(g); 
  const goalPos = new CANNON.Vec3(0, 5, CFG.field.depth / 2); 
  vip = { body: b, mesh: g, hp: 100, goal: goalPos }; 
  const geo = new THREE.ConeGeometry(1, 40, 32, 1, true); const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending }); 
  vipGoalMesh = new THREE.Mesh(geo, mat); vipGoalMesh.position.set(goalPos.x, 20, goalPos.z); scene.add(vipGoalMesh); 
}

// --------------------------------------------------
// 4. VR & MOBILE INPUTS
// --------------------------------------------------

// --- VR Helper Functions ---
function updateDynamicBarrier(state, currentHandPos, updatePhysics) {
  const dx = Math.abs(currentHandPos.x - state.startPos.x);
  const dy = Math.abs(currentHandPos.y - state.startPos.y);
  const dz = Math.abs(currentHandPos.z - state.startPos.z);
  const sensitivity = 2.0; 
  const sx = Math.max(0.2, dx * sensitivity * 2); 
  const sy = Math.max(0.2, dy * sensitivity * 2);
  const sz = Math.max(0.2, dz * sensitivity * 2);
  const cx = (state.startPos.x + currentHandPos.x) / 2;
  const cy = (state.startPos.y + currentHandPos.y) / 2;
  const cz = (state.startPos.z + currentHandPos.z) / 2;
  state.mesh.position.set(cx, cy, cz);
  state.mesh.scale.set(sx, sy, sz);
  if (updatePhysics && state.body) {
    world.removeBody(state.body);
    const newBody = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek') });
    newBody.position.set(cx, cy, cz);
    newBody.addShape(new CANNON.Box(new CANNON.Vec3(sx/2, sy/2, sz/2)));
    world.addBody(newBody);
    state.body = newBody;
  }
}

function finalizeBarrier(state, isGhost) {
  const finalPos = state.mesh.position.clone();
  const finalScale = state.mesh.scale.clone();
  scene.remove(state.mesh);
  if (state.body) world.removeBody(state.body);
  createKekkai(finalPos, finalScale, 0, isGhost);
}

// --- VR Input Handling ---
function handleVRInput() {
  if (!renderer.xr.isPresenting) return;
  const session = renderer.xr.getSession();
  if (!session) return;

  const cam = renderer.xr.getCamera();
  const d = new THREE.Vector3(); cam.getWorldDirection(d); d.y = 0; d.normalize();
  const r = new THREE.Vector3(-d.z, 0, d.x);

  for (const src of session.inputSources) {
    if (!src.gamepad) continue;
    const gp = src.gamepad;
    const hand = src.handedness;
    const idx = (hand === 'left') ? 0 : 1;
    if (!controllers[idx]) continue;
    const ctrlPos = controllers[idx].position;

    if (hand === 'left') {
      if (gp.axes.length >= 4) { input.x = gp.axes[2]; input.y = gp.axes[3]; }
      if (gp.buttons[0]?.pressed) { if (!vrState.left.triggerHeld) { actionKai(); vrState.left.triggerHeld = true; } } else { vrState.left.triggerHeld = false; }
      
      const grip = gp.buttons[1]?.pressed;
      if (grip) {
        if (!vrState.left.drawing) {
          if (kekkaiList.length >= CFG.kekkai.max) { showMsg("上限", "#f44"); } 
          else {
            vrState.left.drawing = true; vrState.left.startPos.copy(ctrlPos);
            const g = new THREE.BoxGeometry(1, 1, 1);
            const m = new THREE.MeshPhongMaterial({ color: CFG.colors.drawPhys, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            vrState.left.mesh = new THREE.Mesh(g, m);
            vrState.left.mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })));
            vrState.left.mesh.position.copy(vrState.left.startPos); vrState.left.mesh.scale.set(0.1, 0.1, 0.1); scene.add(vrState.left.mesh);
            vrState.left.body = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek') });
            vrState.left.body.addShape(new CANNON.Box(new CANNON.Vec3(0.05, 0.05, 0.05)));
            vrState.left.body.position.copy(vrState.left.startPos);
            world.addBody(vrState.left.body);
          }
        } else { if (vrState.left.mesh && vrState.left.body) updateDynamicBarrier(vrState.left, ctrlPos, true); }
      } else {
        if (vrState.left.drawing) {
          if (vrState.left.mesh && vrState.left.body) finalizeBarrier(vrState.left, false);
          vrState.left.drawing = false; vrState.left.mesh = null; vrState.left.body = null;
        }
      }
    }

    if (hand === 'right') {
      const turnVal = gp.axes[2];
      if (Math.abs(turnVal) > 0.5) { if (!vrState.right.snapTurn) { camAngle.yaw -= Math.sign(turnVal) * Math.PI / 4; vrState.right.snapTurn = true; } } else { vrState.right.snapTurn = false; }
      if (gp.buttons[4]?.pressed && Math.abs(playerBody.velocity.y) < 1) playerBody.velocity.y = CFG.player.jump;
      if (gp.buttons[5]?.pressed) { if (!vrState.right.bBtnHeld) { currentDist = (currentDist === CFG.dist.near) ? CFG.dist.far : CFG.dist.near; showMsg(currentDist === CFG.dist.near ? "近" : "遠", "#fff"); vrState.right.bBtnHeld = true; } } else { vrState.right.bBtnHeld = false; }
      if (gp.buttons[0]?.pressed) { if (!vrState.right.triggerHeld) { actionMetsu(); vrState.right.triggerHeld = true; } } else { vrState.right.triggerHeld = false; }
      
      const grip = gp.buttons[1]?.pressed;
      if (grip) {
        if (!vrState.right.drawing) {
          if (kekkaiList.length >= CFG.kekkai.max) { showMsg("上限", "#f44"); } 
          else {
            vrState.right.drawing = true; vrState.right.startPos.copy(ctrlPos);
            const g = new THREE.BoxGeometry(1, 1, 1);
            const m = new THREE.MeshPhongMaterial({ color: CFG.colors.drawGhost, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
            vrState.right.mesh = new THREE.Mesh(g, m);
            vrState.right.mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })));
            vrState.right.mesh.position.copy(vrState.right.startPos); vrState.right.mesh.scale.set(0.1, 0.1, 0.1); scene.add(vrState.right.mesh);
          }
        } else { if (vrState.right.mesh) updateDynamicBarrier(vrState.right, ctrlPos, false); }
      } else {
        if (vrState.right.drawing) {
          if (vrState.right.mesh) finalizeBarrier(vrState.right, true);
          vrState.right.drawing = false; vrState.right.mesh = null;
        }
      }
    }
  }

  const m = d.multiplyScalar(-input.y).add(r.multiplyScalar(input.x)).multiplyScalar(CFG.player.speed);
  playerBody.velocity.x = m.x; playerBody.velocity.z = m.z;
  playerGroup.position.copy(playerBody.position); playerGroup.rotation.y = camAngle.yaw;
}

// --- Mobile/PC Inputs (Legacy) ---
function createActiveMobile() { const p = aimMarker.position.clone(), r = camAngle.yaw; const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek') }); b.position.copy(p); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), r); world.addBody(b); const g = new THREE.BoxGeometry(1, 1, 1), m = new THREE.MeshPhongMaterial({ color: CFG.colors.drawPhys, transparent: true, opacity: 0.5, side: THREE.DoubleSide }); const mesh = new THREE.Mesh(g, m); mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); mesh.position.copy(p); mesh.rotation.y = r; scene.add(mesh); return { body: b, mesh: mesh, startP: p, startR: r, currentS: { x: 1, y: 1, z: 1 } }; }
function updateActiveMobile(k, dx, dy) { const sx = 1.0 + Math.max(0, dx), sy = 1.0 + Math.max(0, dy), sz = sx; k.currentS = { x: sx, y: sy, z: sz }; k.mesh.scale.set(sx, sy, sz); const newY = k.startP.y + (sy - 1.0) / 2; k.mesh.position.y = newY; k.body.position.y = newY; k.body.shapes = []; k.body.addShape(new CANNON.Box(new CANNON.Vec3(sx / 2, sy / 2, sz / 2))); }
function finalizeMobile(k) { k.mesh.material.color.setHex(CFG.colors.kekkai); k.mesh.material.opacity = 0.5; kekkaiList.push({ body: k.body, mesh: k.mesh, shrinking: false, isGhost: false }); spawnText("結", k.mesh.position, "#ff0"); updateHUD(); }
function setupMobileInputs(){
  els.stick.addEventListener('touchstart',e=>{e.preventDefault();if(stickId!==null)return;const t=e.changedTouches[0];stickId=t.identifier;const r=els.stick.getBoundingClientRect();stickStart={x:r.left+r.width/2,y:r.top+r.height/2};tapTime=Date.now();tapPos={x:t.clientX,y:t.clientY};moveStick(t.clientX,t.clientY);},{passive:false});
  els.stick.addEventListener('touchmove',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===stickId)moveStick(e.changedTouches[i].clientX,e.changedTouches[i].clientY);},{passive:false});
  const endStick=e=>{for(let i=0;i<e.changedTouches.length;i++){const t=e.changedTouches[i];if(t.identifier===stickId){if(Date.now()-tapTime<200&&Math.hypot(t.clientX-tapPos.x,t.clientY-tapPos.y)<15){if(playerBody&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;}stickId=null;input.x=0;input.y=0;els.knob.style.transform='translate(-50%,-50%)';}}};
  els.stick.addEventListener('touchend',endStick);els.stick.addEventListener('touchcancel',endStick);
  function moveStick(cx,cy){let dx=cx-stickStart.x,dy=cy-stickStart.y;const d=Math.hypot(dx,dy),max=(els.stick.offsetWidth/2)*0.8;if(d>max){dx*=max/d;dy*=max/d;}input.x=dx/max;input.y=dy/max;els.knob.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;}
  renderer.domElement.addEventListener('touchstart',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++){if(lookId===null&&e.changedTouches[i].target===renderer.domElement){lookId=e.changedTouches[i].identifier;lastLook={x:e.changedTouches[i].clientX,y:e.changedTouches[i].clientY};}}},{passive:false});
  renderer.domElement.addEventListener('touchmove',e=>{e.preventDefault();if(lookId===null)return;for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===lookId){const t=e.changedTouches[i];camAngle.yaw-=(t.clientX-lastLook.x)*0.004;camAngle.pitch-=(t.clientY-lastLook.y)*0.004;camAngle.pitch=Math.max(-1.5,Math.min(1.5,camAngle.pitch));lastLook={x:t.clientX,y:t.clientY};}}},{passive:false});
  renderer.domElement.addEventListener('touchend',e=>{for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===lookId)lookId=null;});
  els.btnJump.addEventListener('touchstart',e=>{e.preventDefault();if(playerBody&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;});
  els.btnDist.addEventListener('touchstart',e=>{e.preventDefault();currentDist=(currentDist===CFG.dist.near)?CFG.dist.far:CFG.dist.near;els.distLabel.textContent=(currentDist===CFG.dist.near)?"近":"遠";showMsg(`射程: ${els.distLabel.textContent}`,"#fff");});
  els.btnAct.addEventListener('touchstart',e=>{e.preventDefault();if(actId!==null)return;const t=e.changedTouches[0];actId=t.identifier;actStartPos={x:t.clientX,y:t.clientY};});
  els.btnAct.addEventListener('touchend',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===actId){const t=e.changedTouches[i];if(Math.hypot(t.clientX-actStartPos.x,t.clientY-actStartPos.y)>20)actionKai();else actionMetsu();actId=null;}}});
  els.modeBtn.addEventListener('touchstart',e=>{e.preventDefault(); e.stopPropagation(); isPhysMode = !isPhysMode; els.modeBtn.textContent = isPhysMode ? "モード: 顕現" : "モード: 幽体"; els.modeBtn.className = isPhysMode ? "phys" : "ghost"; els.btnDraw.style.background = isPhysMode ? "linear-gradient(135deg, #FFD700, #FF8C00)" : "linear-gradient(135deg, #03a9f4, #0288d1)"; els.btnDraw.innerHTML = isPhysMode ? "顕<br><span style='font-size:10px'>Hold</span>" : "結<br><span style='font-size:10px'>Hold</span>"; showMsg(isPhysMode ? "物理顕現モード" : "幽体結界モード", "#fff");});
  els.btnDraw.addEventListener('touchstart',e=>{ e.preventDefault(); if(drawId!==null)return; if(kekkaiList.length>=CFG.kekkai.max){showMsg("上限到達","#f44");return;} const t=e.changedTouches[0]; drawId=t.identifier; els.btnDraw.classList.add('drawing'); if(isPhysMode) { activePhysKekkai = createActiveMobile(); activePhysKekkai.startX=t.clientX; activePhysKekkai.startY=t.clientY; } else { drawState.active=true; drawState.startX=t.clientX; drawState.startY=t.clientY; const gg=new THREE.BoxGeometry(1,1,1),gm=new THREE.MeshPhongMaterial({color:CFG.colors.drawGhost,transparent:true,opacity:0.5, side: THREE.DoubleSide}); drawState.ghost=new THREE.Mesh(gg,gm); drawState.ghost.add(new THREE.LineSegments(new THREE.EdgesGeometry(gg), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); drawState.ghost.position.copy(aimMarker.position); drawState.ghost.rotation.y=camAngle.yaw; scene.add(drawState.ghost); } });
  els.btnDraw.addEventListener('touchmove',e=>{ e.preventDefault(); if(drawId===null)return; for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===drawId){ const t=e.changedTouches[i]; if(isPhysMode && activePhysKekkai) { const dx=Math.abs(t.clientX-activePhysKekkai.startX)*0.06, dy=(activePhysKekkai.startY-t.clientY)*0.06; updateActiveMobile(activePhysKekkai, dx, dy); } else if(drawState.active && drawState.ghost) { const dx=Math.abs(t.clientX-drawState.startX)*0.06, dy=(drawState.startY-t.clientY)*0.06; const sxz=1.0+Math.max(0,dx), sy=1.0+Math.max(0,dy); drawState.ghost.scale.set(sxz,sy,sxz); drawState.ghost.position.y=aimMarker.position.y+(sy/2-0.5); } }} });
  els.btnDraw.addEventListener('touchend',e=>{ e.preventDefault(); for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===drawId){ if(isPhysMode && activePhysKekkai) { finalizeMobile(activePhysKekkai); activePhysKekkai=null; } else if(drawState.ghost) { createKekkai(drawState.ghost.position,drawState.ghost.scale,drawState.ghost.rotation.y, true); safeRemoveMesh(drawState.ghost); drawState.ghost=null; drawState.active=false; } drawId=null; els.btnDraw.classList.remove('drawing'); }} });
}

// --------------------------------------------------
// 5. ENVIRONMENT SETUP
// --------------------------------------------------
function setupEnvironment(mat){
  const sun=new THREE.DirectionalLight(0xffffee,1.2); sun.position.set(-50,100,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); sun.shadow.camera.left=-100; sun.shadow.camera.right=100; sun.shadow.camera.top=100; sun.shadow.camera.bottom=-100; scene.add(sun); scene.add(new THREE.AmbientLight(0x555566,0.6));
  const gGeo=new THREE.PlaneGeometry(CFG.field.width+40,CFG.field.depth+40); const gMat=new THREE.MeshStandardMaterial({color:CFG.colors.ground,roughness:0.9}); const ground=new THREE.Mesh(gGeo,gMat); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground); const gBody=new CANNON.Body({mass:0,material:mat}); gBody.addShape(new CANNON.Plane()); gBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(gBody);
  const createBox=(x,y,z,w,h,d,col,tr=false,op=1,rotY=0)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col,transparent:tr,opacity:op})); m.position.set(x,y,z); m.rotation.y=rotY; m.castShadow=!tr; m.receiveShadow=true; scene.add(m); const b=new CANNON.Body({mass:0,material:mat}); b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))); b.position.copy(m.position); b.quaternion.copy(m.quaternion); world.addBody(b); return m; };
  const createVisualBox=(x,y,z,w,h,d,col,rotY=0)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col})); m.position.set(x,y,z); m.rotation.y=rotY; m.castShadow=true; m.receiveShadow=true; scene.add(m); return m; };

  const FW=CFG.field.width,FD=CFG.field.depth,WH=8;
  const gateW = 24; const wallW = (FW - gateW) / 2;
  createBox(-FW/2 + wallW/2, WH/2, FD/2+1, wallW, WH, 2, CFG.colors.wall); 
  createBox(FW/2 - wallW/2, WH/2, FD/2+1, wallW, WH, 2, CFG.colors.wall); 
  createBox(-FW/2-1,WH/2,0,2,WH,FD+2,CFG.colors.wall); 
  createBox(FW/2+1,WH/2,0,2,WH,FD+2,CFG.colors.wall); 
  
  const bH=30,bZ=-FD/2-20; createBox(0,bH/2,bZ,FW,bH,40,CFG.colors.building);
  for(let i=-FW/2+5;i<FW/2;i+=10)for(let j=5;j<28;j+=7){const w=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial({color:0x87CEFA})); w.position.set(i,j,bZ+20+0.1); scene.add(w);}
  createBox(0, bH+1, bZ, FW, 2, 40, CFG.colors.concrete);

  const rampH = 0.6, rampW = 1.2; 
  const createRampFence = (x, z, length, rotY) => {
      const shape = new THREE.Shape(); shape.moveTo(0,0); shape.lineTo(0, rampH); shape.lineTo(rampW, 0); shape.lineTo(0,0);
      const geo = new THREE.ExtrudeGeometry(shape, { steps: 1, depth: length, bevelEnabled: false });
      const m = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: CFG.colors.concrete}));
      m.position.set(0, 0, -length/2); 
      const wrapper = new THREE.Object3D(); wrapper.add(m);
      wrapper.position.set(x, bH+1, z); wrapper.rotation.y = rotY; scene.add(wrapper);
      const ang = Math.atan2(rampH, rampW); const hyp = Math.sqrt(rampH**2 + rampW**2);
      const b = new CANNON.Body({mass:0, material:mat});
      b.addShape(new CANNON.Box(new CANNON.Vec3(hyp/2, 0.1, length/2)), new CANNON.Vec3(rampW/2, rampH/2, 0), new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -ang));
      b.addShape(new CANNON.Box(new CANNON.Vec3(0.1, rampH/2, length/2)), new CANNON.Vec3(0, rampH/2, 0));
      b.position.set(x, bH+1, z); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rotY); world.addBody(b);
  };
  createRampFence(0, bZ-20, FW, -Math.PI/2); createRampFence(-FW/2, bZ, 40, 0); createRampFence(FW/2, bZ, 40, Math.PI);
  const landW=8; const gapW = landW + 2; const landX = FW/2 - landW/2 - 2;
  const gapStart = landX - gapW/2; const gapEnd = landX + gapW/2;
  createRampFence((-FW/2 + gapStart)/2, bZ+20, gapStart - (-FW/2), Math.PI/2); 
  createRampFence((gapEnd + FW/2)/2, bZ+20, FW/2 - gapEnd, Math.PI/2); 

  const wtX = FW/2 - 8, wtZ = bZ - 8, wtBaseH = bH+2; const wtTank = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 6, 16), new THREE.MeshStandardMaterial({color: CFG.colors.concrete})); wtTank.position.set(wtX, wtBaseH + 8, wtZ); wtTank.castShadow=true; scene.add(wtTank); const wtTankBody = new CANNON.Body({mass:0, material:mat}); wtTankBody.addShape(new CANNON.Cylinder(4,4,6,16)); wtTankBody.position.copy(wtTank.position); world.addBody(wtTankBody);
  for(let i=0; i<4; i++){ const ang = i * Math.PI/2; const m=new THREE.Mesh(new THREE.BoxGeometry(0.5,5,0.5), new THREE.MeshStandardMaterial({color:CFG.colors.iron})); m.position.set(wtX + Math.cos(ang)*3, wtBaseH + 2.5, wtZ + Math.sin(ang)*3); scene.add(m); }

  const stW=6, stRise=bH, stRun=60; const landD=stW+2; const landY = bH; const landZ = bZ + 20 + landD/2;
  createBox(landX, landY, landZ, landW, 1, landD, CFG.colors.concrete); 
  const slLen=Math.sqrt(stRun**2+stRise**2), slAng=Math.atan2(stRise, stRun); const slMidX = landX - landW/2 - stRun/2; const slMidY = stRise/2; 
  const slZ = bZ + 20 + stW/2 + 0.05; 
  const slB=new CANNON.Body({mass:0,material:mat}); slB.addShape(new CANNON.Box(new CANNON.Vec3(slLen/2,0.5,stW/2))); slB.position.set(slMidX, slMidY, slZ); const slQ = new THREE.Quaternion(); slQ.setFromEuler(new THREE.Euler(0,0,slAng)); slB.quaternion.copy(slQ); world.addBody(slB);
  const slM=new THREE.Mesh(new THREE.BoxGeometry(slLen,1,stW), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); slM.position.copy(slB.position); slM.quaternion.copy(slB.quaternion); scene.add(slM);
  
  const brRun=3.0, brRise=1.5; const brLen=Math.sqrt(brRun**2+brRise**2)+0.5; const brAng=Math.atan2(brRise, brRun); 
  const brB = new CANNON.Body({mass:0, material:mat}); brB.addShape(new CANNON.Box(new CANNON.Vec3(landW/2, 0.2, brLen/2))); 
  brB.position.set(landX, bH + 0.5 + brRise/2, bZ + 21.5); brB.quaternion.setFromEuler(brAng, 0, 0); world.addBody(brB);
  const brM = new THREE.Mesh(new THREE.BoxGeometry(landW, 0.4, brLen), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); brM.position.copy(brB.position); brM.quaternion.copy(brB.quaternion); scene.add(brM);
  
  const hrH=1.2, hrT=0.1; const cRail = (x,y,z,w,h,d,rx=0,ry=0,rz=0) => { const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:CFG.colors.iron})); m.position.set(x,y,z); m.rotation.set(rx,ry,rz); scene.add(m); const b=new CANNON.Body({mass:0,material:mat}); b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))); b.position.copy(m.position); b.quaternion.copy(m.quaternion); world.addBody(b); };
  cRail(slMidX, slMidY+hrH/2, slZ-stW/2+hrT/2+0.05, slLen, hrH, hrT, 0,0,slAng); cRail(slMidX, slMidY+hrH/2, slZ+stW/2-hrT/2-0.05, slLen, hrH, hrT, 0,0,slAng);
  cRail(landX, landY+hrH/2, landZ+landD/2-hrT/2, landW, hrH, hrT); cRail(landX+landW/2-hrT/2, landY+hrH/2, landZ, hrT, hrH, landD);
  cRail(landX-landW/2+hrT/2, bH+0.5+brRise/2+hrH/2, bZ+21.5, hrT, hrH, brLen, brAng,0,0); cRail(landX+landW/2-hrT/2, bH+0.5+brRise/2+hrH/2, bZ+21.5, hrT, hrH, brLen, brAng,0,0);

  const pX = 35, pZ = 10, pW = 20, pD = 40, pBaseH = 4;
  createBox(pX, pBaseH/2, pZ, pW+4, pBaseH, pD+4, CFG.colors.concrete);
  createBox(pX, pBaseH+1, pZ - pD/2 - 1, pW+2, 2, 2, CFG.colors.concrete); createBox(pX, pBaseH+1, pZ + pD/2 + 1, pW+2, 2, 2, CFG.colors.concrete); createBox(pX - pW/2 - 1, pBaseH+1, pZ, 2, 2, pD, CFG.colors.concrete); createBox(pX + pW/2 + 1, pBaseH+1, pZ, 2, 2, pD, CFG.colors.concrete);
  const water = new THREE.Mesh(new THREE.PlaneGeometry(pW, pD), new THREE.MeshBasicMaterial({color:0x00aaff, transparent:true, opacity:0.6, side:THREE.DoubleSide})); water.rotation.x = -Math.PI/2; water.position.set(pX, pBaseH+1.5, pZ); scene.add(water);
  const prRun=25, prRise=pBaseH, prW=4; const prLen=Math.sqrt(prRun**2+prRise**2), prAng=Math.atan2(prRise, prRun);
  const prMidY = prRise/2; const prMidZ = pZ; 
  const prMidX_L = pX - pW/2 - prW/2 - 2; 
  const prB_L=new CANNON.Body({mass:0,material:mat}); prB_L.addShape(new CANNON.Box(new CANNON.Vec3(prW/2, 0.5, prLen/2))); prB_L.position.set(prMidX_L, prMidY, prMidZ);
  const prQ_L = new THREE.Quaternion(); prQ_L.setFromEuler(new THREE.Euler(prAng, 0, 0)); prB_L.quaternion.copy(prQ_L); world.addBody(prB_L);
  const prM_L=new THREE.Mesh(new THREE.BoxGeometry(prW, 1, prLen), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); prM_L.position.copy(prB_L.position); prM_L.quaternion.copy(prB_L.quaternion); scene.add(prM_L);
  const prMidX_R = pX + pW/2 + prW/2 + 2;
  const prB_R=new CANNON.Body({mass:0,material:mat}); prB_R.addShape(new CANNON.Box(new CANNON.Vec3(prW/2, 0.5, prLen/2))); prB_R.position.set(prMidX_R, prMidY, prMidZ);
  const prQ_R = new THREE.Quaternion(); prQ_R.setFromEuler(new THREE.Euler(prAng, 0, 0)); prB_R.quaternion.copy(prQ_R); world.addBody(prB_R);
  const prM_R=new THREE.Mesh(new THREE.BoxGeometry(prW, 1, prLen), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); prM_R.position.copy(prB_R.position); prM_R.quaternion.copy(prB_R.quaternion); scene.add(prM_R);

  const gZ = FD/2; createBox(-gateW/2-1, 4, gZ, 2, 8, 2, CFG.colors.wall); createBox(gateW/2+1, 4, gZ, 2, 8, 2, CFG.colors.wall);
  for(let i=-gateW/2; i<=gateW/2; i+=1.0) createVisualBox(i, 3, gZ, 0.2, 6, 0.2, CFG.colors.iron); 
  createVisualBox(0, 5.5, gZ, gateW, 0.3, 0.3, CFG.colors.iron); createVisualBox(0, 0.5, gZ, gateW, 0.3, 0.3, CFG.colors.iron);
  const gateB = new CANNON.Body({mass:0, material:mat}); gateB.addShape(new CANNON.Box(new CANNON.Vec3(gateW/2, 3, 0.1))); gateB.position.set(0, 3, gZ); world.addBody(gateB);

  const createTree = (x, z) => { const trunkH = 4 + Math.random()*2; createBox(x, trunkH/2, z, 1, trunkH, 1, CFG.colors.wood); const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(2.5 + Math.random(), 1), new THREE.MeshStandardMaterial({color:CFG.colors.leaf, roughness:0.8})); leaves.position.set(x, trunkH+2, z); leaves.castShadow=true; scene.add(leaves); };
  for(let i=0; i<5; i++) createTree(-FW/2+3, -FD/2 + 10 + i*20); for(let i=0; i<5; i++) createTree(FW/2-3, -FD/2 + 10 + i*20);
}

// --------------------------------------------------
// 6. VR INIT & MAIN LOOP
// --------------------------------------------------
function setupVRControllers() { const modelFactory = new XRControllerModelFactory(); for (let i = 0; i < 2; i++) { const controller = renderer.xr.getController(i); playerGroup.add(controller); controllers.push(controller); const grip = renderer.xr.getControllerGrip(i); grip.add(modelFactory.createControllerModel(grip)); playerGroup.add(grip); controllerGrips.push(grip); } }
function setupVRHud() { const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128; vrHudCtx = canvas.getContext('2d'); const tex = new THREE.CanvasTexture(canvas); vrHudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 0.25), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.9, depthTest: false })); vrHudMesh.position.set(0, 0.3, -1); vrHudMesh.renderOrder = 9999; camera.add(vrHudMesh); }

function loop(t) {
  // Logic Flow: 1. Input/Logic -> 2. Physics Step -> 3. Rendering
  // IMPORTANT: VR Input handles dynamic body recreation. This must happen BEFORE world.step to avoid glitches.
  if (renderer.xr.isPresenting) handleVRInput(); 

  const dt = Math.min((t - lastT) / 1000, 0.1); lastT = t; 
  world.step(1 / 60, dt, 3);

  if (!renderer.xr.isPresenting) { 
    // Mobile/PC movement logic
    const yaw = camAngle.yaw, fwd = new THREE.Vector3(input.x, 0, input.y).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw); 
    playerBody.velocity.x = fwd.x * CFG.player.speed; playerBody.velocity.z = fwd.z * CFG.player.speed; 
    playerGroup.position.copy(playerBody.position).add(new THREE.Vector3(0, CFG.player.height, 0)); 
    playerGroup.rotation.y = yaw; camera.rotation.x = camAngle.pitch; 
  }
  
  updateAimMarker(); if (t > gameState.nextSpawn) { spawnEnemy(); gameState.nextSpawn = t + 3000 - gameState.wave * 100; }
  items.forEach(it => { it.mesh.position.copy(it.body.position); it.mesh.rotation.y += 0.05; if (playerBody.position.distanceTo(it.body.position) < 2.0) { healPlayer(20); scene.remove(it.mesh); world.removeBody(it.body); items = items.filter(i => i !== it); } });
  if (vip) { vip.mesh.position.copy(vip.body.position); const tg = vip.goal.vsub(vip.body.position); if(vipGoalMesh) vipGoalMesh.rotation.y += 0.02; if (tg.length() < 6.0) { showMsg("護衛成功!", "#0f0"); world.removeBody(vip.body); scene.remove(vip.mesh); vip = null; els.vipBox.style.display = "none"; gameState.isVipMode = false; if(vipGoalMesh) { scene.remove(vipGoalMesh); vipGoalMesh = null; }} else { tg.normalize(); vip.body.velocity.x = tg.x * 7; vip.body.velocity.z = tg.z * 7; els.vipHpBar.style.width = vip.hp + "%"; if (vip.hp <= 0) { showMsg("護衛失敗...", "#f00"); world.removeBody(vip.body); scene.remove(vip.mesh); vip = null; els.vipBox.style.display = "none"; gameState.isVipMode = false; if(vipGoalMesh) { scene.remove(vipGoalMesh); vipGoalMesh = null; }} } }
  const fW = CFG.field.width, fD = CFG.field.depth; enemies.forEach(e => { e.mesh.position.copy(e.body.position); e.mesh.quaternion.copy(e.body.quaternion); if (e.body.position.y < -10) killEnemy(e); const isOut = Math.abs(e.body.position.x) > fW / 2 + 2 || Math.abs(e.body.position.z) > fD / 2 + 2; if (isOut) { if (!e.body.outsideTimer) e.body.outsideTimer = 0; e.body.outsideTimer += dt; if (e.body.outsideTimer > 20.0) { showMsg("敵逃亡!", "#aaa"); removeEnemy(e); return; } const cu = new CANNON.Vec3(0, 25, 0), dr = cu.vsub(e.body.position); dr.normalize(); e.body.applyForce(dr.scale(e.isGiant ? 200 : 40), e.body.position); } else { e.body.outsideTimer = 0; const target = (vip && vip.hp > 0) ? vip.body.position : playerBody.position; const d = target.vsub(e.body.position); d.normalize(); e.body.applyForce(d.scale(e.isGiant ? 100 : 20), e.body.position); if (vip && e.body.position.distanceTo(vip.body.position) < 2.0 && Math.random() < 0.05) { vip.hp -= 5; spawnParticle(vip.body.position, 5, 0xff0000); } } });
  renderer.render(scene, camera);
}

function init() {
  try {
    scene = new THREE.Scene(); scene.background = new THREE.Color(CFG.colors.sky); scene.fog = new THREE.FogExp2(CFG.colors.sky, 0.005); 
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200); 
    playerGroup = new THREE.Group(); playerGroup.add(camera); 
    camera.position.set(0, CFG.player.height, 0); scene.add(playerGroup); 
    renderer = new THREE.WebGLRenderer({ antialias: true }); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.xr.enabled = true; 
    document.body.appendChild(renderer.domElement);

    world = new CANNON.World(); world.gravity.set(0, -30, 0);
    const mDef=new CANNON.Material('def'), mPly=new CANNON.Material('ply'), mEne=new CANNON.Material('ene'), mKek=new CANNON.Material('kek');
    
    world.addContactMaterial(new CANNON.ContactMaterial(mPly, mDef, { friction: 0.0, restitution: 0.0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mEne, mDef, { friction: 0.5, restitution: 0.3 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek, mEne, { friction: 0.1, restitution: 0.8 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek, mPly, { friction: 0.8, restitution: 0.0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mPly, mEne, { friction: 0.5, restitution: 0.5 }));

    playerBody = new CANNON.Body({ mass: 70, shape: new CANNON.Sphere(0.6), material: mPly, fixedRotation: true, linearDamping: 0.9 });
    playerBody.position.set(0, 5, 30); world.addBody(playerBody);
    playerBody.addEventListener('collide', (e) => { if (e.body && e.body.material && e.body.material.name === 'ene') { const relVel = e.contact.getImpactVelocityAlongNormal(); if (Math.abs(relVel) > 2.0) { takeDamage(Math.floor(Math.abs(relVel) * 2)); const normal = new CANNON.Vec3(); e.contact.ni.negate(normal); playerBody.applyImpulse(normal.scale(50 * Math.abs(relVel)), playerBody.position); } } });

    setupEnvironment(mDef);
    setupVRControllers();
    setupVRHud();
    setupMobileInputs();
    
    const aimGeo = new THREE.SphereGeometry(0.3, 16, 16); const aimMat = new THREE.MeshBasicMaterial({ color: CFG.colors.marker, transparent: true, opacity: 0.7, depthTest: false }); 
    aimMarker = new THREE.Mesh(aimGeo, aimMat); aimMarker.renderOrder = 999; scene.add(aimMarker);

    for (let i = 0; i < 3; i++) spawnEnemy(); 
    renderer.setAnimationLoop(loop);
  } catch (e) { console.error(e); alert("初期化エラー: " + e.message); }
}

document.getElementById('vrBtn').addEventListener('click', async () => { if (currentSession) return; if (!navigator.xr) return; try { const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] }); renderer.xr.setSession(session); currentSession = session; els.novr.forEach(e => e.style.opacity = 0); session.addEventListener('end', () => { currentSession = null; els.novr.forEach(e => e.style.opacity = 1); }); } catch (e) { console.error("VR Init Error:", e); alert("VRモードの起動に失敗しました: " + e.message); } });
window.onload = init;
</script>
</body>
</html>
