<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR — ハイブリッド版</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<style>
  html, body { height: 100%; margin: 0; background: #87CEEB; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
  canvas { display: block; width: 100%; height: 100%; }
  #error-log { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:#ff5555; padding:20px; z-index:9999; white-space:pre-wrap; font-weight:bold; overflow:auto; }
  #hud { position: fixed; top: 16px; left: 16px; pointer-events: none; z-index: 10; }
  @supports (padding-top: env(safe-area-inset-top)) { #hud { top: calc(env(safe-area-inset-top) + 10px); left: calc(env(safe-area-inset-left) + 16px); } }
  .hud-box { background: rgba(0, 30, 60, 0.7); padding: 8px 16px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); margin-bottom: 8px; backdrop-filter: blur(4px); }
  .big-text { font-size: 18px; font-weight: bold; color: #ffeb3b; text-shadow: 1px 1px 2px #000; }
  .sub-text { font-size: 14px; color: #e0e0e0; }
  #msgArea { position: fixed; top: 35%; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
  .flash-msg { font-size: 40px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #f0a, 2px 2px 0 #000; opacity: 0; transition: opacity 0.3s; }
  #uiLayer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
  #stickZone { position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px; pointer-events: auto; margin-bottom: env(safe-area-inset-bottom); margin-left: env(safe-area-inset-left); }
  .stick-base { width: 100%; height: 100%; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; position: relative; }
  .stick-knob { width: 60px; height: 60px; background: #fff; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 10px rgba(0,0,0,0.3); pointer-events: none; }
  #padArea { position: absolute; bottom: 40px; right: 40px; width: 200px; height: 200px; pointer-events: none; margin-bottom: env(safe-area-inset-bottom); margin-right: env(safe-area-inset-right); }
  .btn { position: absolute; width: 65px; height: 65px; z-index: 10; border-radius: 50%; border: 2px solid rgba(255,255,255,0.6); background: rgba(40,50,80,0.8); color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; pointer-events: auto; touch-action: manipulation; transition: transform 0.1s; }
  .btn:active { transform: scale(0.9); background: rgba(60,70,100,0.9); }
  #btnUp { top: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #607d8b, #455a64); }
  #btnDown { bottom: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #9c27b0, #7b1fa2); width: 75px; height: 75px; font-size: 16px; }
  #btnLeft { top: 50%; left: 0; transform: translateY(-50%); background: linear-gradient(135deg, #f44336, #c62828); }
  #btnRight { top: 50%; right: 0; transform: translateY(-50%); background: linear-gradient(135deg, #03a9f4, #0288d1); width: 75px; height: 75px; font-size: 18px; }
  #btnRight.drawing { background: #fff; color: #0288d1; transform: translateY(-50%) scale(1.1); }
  
  /* モード切替ボタン */
  #modeSwitch { position: absolute; top: -60px; right: 0; width: 100px; height: 40px; background: rgba(0,0,0,0.6); border: 2px solid #fff; border-radius: 20px; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:bold; pointer-events:auto; transition: background 0.3s; }
  #modeSwitch.phys { background: linear-gradient(90deg, #FFD700, #FF8C00); color:#000; border-color:#fff; }
  #modeSwitch.ghost { background: linear-gradient(90deg, #00bfff, #0000ff); color:#fff; border-color:#00ffff; }

  @media (orientation: portrait) {
    #stickZone { width: 120px; height: 120px; bottom: 20px; left: 20px; } .stick-knob { width: 50px; height: 50px; }
    #padArea { width: 170px; height: 170px; bottom: 20px; right: 20px; } .btn { width: 55px; height: 55px; font-size: 10px; }
    #btnDown, #btnRight { width: 65px; height: 65px; } .big-text { font-size: 16px; } .sub-text { font-size: 12px; }
  }
  #centerReticle { position: fixed; top: 50%; left: 50%; width: 6px; height: 6px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: 1px solid rgba(0,0,0,0.5); }
  #vrBtn { position: fixed; top: 10px; right: 10px; padding: 8px 16px; background: rgba(0,0,0,0.8); border: 2px solid #fff; color: #fff; border-radius: 6px; z-index: 200; pointer-events: auto; font-weight: bold; cursor: pointer; }
</style>
<script>
  window.onerror = function(msg, url, line) { const box = document.getElementById('error-log'); box.style.display = 'block'; box.textContent += "Error: " + msg + "\nLine: " + line + "\n"; return false; };
</script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>
</head>
<body>
<div id="error-log"></div>
<div id="hud">
  <div class="hud-box"><span class="big-text" id="waveVal">WAVE 1</span><br><span class="sub-text">撃破: <span id="killVal">0</span> / 残: <span id="targetVal" style="color:#f88; font-weight:bold;">3</span></span></div>
  <div class="hud-box"><span class="sub-text">結界: <span id="kekVal" style="color:#00bfff; font-weight:bold;">0</span>/5</span></div>
</div>
<div id="msgArea"><div id="flashMsg" class="flash-msg"></div></div>
<div id="centerReticle"></div>
<button id="vrBtn">VR START</button>
<div id="uiLayer">
  <div id="stickZone"><div class="stick-base"><div id="stickKnob" class="stick-knob"></div></div></div>
  <div id="padArea">
    <div id="modeSwitch" class="ghost">モード: 幽体</div>
    <div id="btnUp" class="btn">距離<br><span id="distLabel" style="color:#fe0">近</span></div>
    <div id="btnLeft" class="btn">滅<br><span style="font-size:10px">⇔解</span></div>
    <div id="btnRight" class="btn">結<br><span style="font-size:10px">Hold</span></div>
    <div id="btnDown" class="btn">跳</div>
  </div>
</div>
<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

const CFG={colors:{sky:0x87CEEB,ground:0xC2B280,kekkai:0x00bfff,ghost:0x00ffaa,physGhost:0xFFD700,marker:0xff0000,wall:0xa0a0a0,building:0xf0f0f0,pool:0x88cccc},player:{speed:12.0,jump:22.0,height:1.7},kekkai:{max:5},dist:{near:8.0,far:20.0},field:{width:120,depth:160}};
let scene,camera,renderer,world,playerBody,playerGroup,enemies=[],kekkaiList=[],gameState={wave:1,kills:0,req:3,nextSpawn:0},currentDist=CFG.dist.near,aimMarker;
let isPhysMode = false; // デフォルトは従来（幽体）モード

const els={
  stick:document.getElementById('stickZone'),knob:document.getElementById('stickKnob'),msg:document.getElementById('flashMsg'),
  btnDist:document.getElementById('btnUp'),btnJump:document.getElementById('btnDown'),btnAct:document.getElementById('btnLeft'),btnDraw:document.getElementById('btnRight'),
  modeBtn:document.getElementById('modeSwitch'),
  distLabel:document.getElementById('distLabel'),wVal:document.getElementById('waveVal'),kVal:document.getElementById('killVal'),tVal:document.getElementById('targetVal'),kekVal:document.getElementById('kekVal')
};

let drawId=null, drawState={active:false,startX:0,startY:0,ghost:null}, activePhysKekkai=null;
let input={x:0,y:0}, camAngle={yaw:0,pitch:0};
let stickId=null, stickStart={x:0,y:0}, tapTime=0, tapPos={x:0,y:0}, actId=null, actStartPos={x:0,y:0}, lookId=null, lastLook={x:0,y:0};

function init(){
  try {
    scene=new THREE.Scene(); scene.background=new THREE.Color(CFG.colors.sky); scene.fog=new THREE.FogExp2(CFG.colors.sky,0.005);
    camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,200);
    playerGroup=new THREE.Group(); playerGroup.add(camera); camera.position.set(0,CFG.player.height,0); scene.add(playerGroup);
    renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth,innerHeight); renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap; renderer.xr.enabled=true; document.body.appendChild(renderer.domElement);
    world=new CANNON.World(); world.gravity.set(0,-30,0);
    const mDef=new CANNON.Material('def'),mPly=new CANNON.Material('ply'),mEne=new CANNON.Material('ene'),mKek=new CANNON.Material('kek');
    world.addContactMaterial(new CANNON.ContactMaterial(mPly,mDef,{friction:0.0,restitution:0.0}));
    world.addContactMaterial(new CANNON.ContactMaterial(mEne,mDef,{friction:0.5,restitution:0.3}));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek,mEne,{friction:0.1,restitution:0.8}));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek,mPly,{friction:0.8,restitution:0.0}));
    playerBody=new CANNON.Body({mass:70,shape:new CANNON.Sphere(0.6),material:mPly,fixedRotation:true,linearDamping:0.9}); playerBody.position.set(0,5,30); world.addBody(playerBody);
    setupEnvironment(mDef);
    const aimGeo=new THREE.SphereGeometry(0.3,16,16),aimMat=new THREE.MeshBasicMaterial({color:CFG.colors.marker,transparent:true,opacity:0.7,depthTest:false});
    aimMarker=new THREE.Mesh(aimGeo,aimMat); aimMarker.renderOrder=999; scene.add(aimMarker);
    setupInputs(); for(let i=0;i<3;i++)spawnEnemy(); renderer.setAnimationLoop(loop);
  } catch(e) { console.error(e); alert("初期化エラー: " + e.message); }
}

function setupEnvironment(mat){
  const sun=new THREE.DirectionalLight(0xffffee,1.2); sun.position.set(-50,100,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); sun.shadow.camera.left=-100; sun.shadow.camera.right=100; sun.shadow.camera.top=100; sun.shadow.camera.bottom=-100; scene.add(sun); scene.add(new THREE.AmbientLight(0x555566,0.6));
  const gGeo=new THREE.PlaneGeometry(CFG.field.width+40,CFG.field.depth+40); const gMat=new THREE.MeshStandardMaterial({color:CFG.colors.ground,roughness:0.9});
  const ground=new THREE.Mesh(gGeo,gMat); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
  const gBody=new CANNON.Body({mass:0,material:mat}); gBody.addShape(new CANNON.Plane()); gBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(gBody);
  const createBox=(x,y,z,w,h,d,col,tr=false,op=1)=>{
    const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col,transparent:tr,opacity:op})); m.position.set(x,y,z); m.castShadow=!tr; m.receiveShadow=true; scene.add(m);
    const b=new CANNON.Body({mass:0,material:mat}); b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))); b.position.copy(m.position); world.addBody(b); return m;
  };
  const FW=CFG.field.width,FD=CFG.field.depth,WH=8;
  createBox(0,WH/2,FD/2+1,FW+2,WH,2,CFG.colors.wall); createBox(-FW/2-1,WH/2,0,2,WH,FD+2,CFG.colors.wall); createBox(FW/2+1,WH/2,0,2,WH,FD+2,CFG.colors.wall);
  const bH=30,bZ=-FD/2-20; createBox(0,bH/2,bZ,FW,bH,40,CFG.colors.building);
  for(let i=-FW/2+5;i<FW/2;i+=10)for(let j=5;j<28;j+=7){const w=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial({color:0x87CEFA})); w.position.set(i,j,bZ+20+0.1); scene.add(w);}
  
  const stW=8, stRun=60, stRise=30, stZ=bZ+20+stW/2;
  const slopeThickness=1.0, midY=stRise/2 - slopeThickness/2;
  const createSlope = (startX, endX) => {
    const run = Math.abs(endX - startX);
    const len = Math.sqrt(run*run + stRise*stRise);
    const ang = Math.atan2(stRise, run);
    const midX = (startX + endX)/2;
    const b=new CANNON.Body({mass:0,material:mat}); b.addShape(new CANNON.Box(new CANNON.Vec3(len/2, slopeThickness/2, stW/2))); b.position.set(midX, midY, stZ);
    const dir = (endX > startX) ? 1 : -1; 
    b.quaternion.setFromEuler(0, 0, dir * ang); world.addBody(b);
    const m=new THREE.Mesh(new THREE.BoxGeometry(len,slopeThickness,stW), new THREE.MeshStandardMaterial({color:0xdddddd})); m.position.copy(b.position); m.quaternion.copy(b.quaternion); m.receiveShadow=true; m.castShadow=true; scene.add(m);
    const r=new THREE.Mesh(new THREE.BoxGeometry(len,0.5,0.2), new THREE.MeshStandardMaterial({color:0x888888})); r.position.copy(b.position); r.position.add(new THREE.Vector3(0, slopeThickness/2+2.0, 0).applyEuler(new THREE.Euler(0,0,dir*ang))); r.position.z += stW/2 - 0.2; r.quaternion.copy(b.quaternion); scene.add(r);
    const landW=6;
    const landX1 = startX - dir*(landW/2); createBox(landX1, 0.25, stZ, landW, 0.5, stW, 0xdddddd); // 下
    const landX2 = endX + dir*(landW/2); createBox(landX2, stRise, stZ, landW, 0.5, stW, 0xdddddd); // 上
    createBox(landX2, stRise, (stZ+(bZ+20))/2-10, landW, 0.5, 25, 0xdddddd); // ブリッジ
    createBox(landX2 + dir*(landW/2), stRise+1.5, stZ, 0.2, 3, stW, 0x888888); // 上手すり奥
    createBox(landX2, stRise+1.5, stZ+stW/2, landW, 3, 0.2, 0x888888); // 上手すり横
  };
  createSlope(5, 55); createSlope(-5, -55);

  const rY=bH, rW=FW, rD=40; 
  createBox(0,rY+1,bZ-rD/2,rW,2,0.5,0x888888); createBox(-rW/2,rY+1,bZ,0.5,2,rD,0x888888); createBox(rW/2,rY+1,bZ,0.5,2,rD,0x888888);
  const gateW=8, rightGateX=55, leftGateX=-55;
  const centerFenceW=(rightGateX-gateW/2)-(leftGateX+gateW/2); createBox(0,rY+1,bZ+rD/2,centerFenceW,2,0.5,0x888888);
  const leftFenceW=(leftGateX-gateW/2)-(-rW/2); createBox(-rW/2+leftFenceW/2,rY+1,bZ+rD/2,leftFenceW,2,0.5,0x888888);
  const rightFenceW=(rW/2)-(rightGateX+gateW/2); createBox(rW/2-rightFenceW/2,rY+1,bZ+rD/2,rightFenceW,2,0.5,0x888888);

  const pX=FW/2-25, pZ=0, pW=30, pD=60, wT=1.0;
  createBox(pX,1.0,pZ,pW,2.0,pD,CFG.colors.pool); createBox(pX,3.0,pZ-pD/2,pW,2.0,wT,CFG.colors.pool); createBox(pX,3.0,pZ+pD/2,pW,2.0,wT,CFG.colors.pool); createBox(pX-pW/2,3.0,pZ,wT,2.0,pD,CFG.colors.pool); createBox(pX+pW/2,3.0,pZ,wT,2.0,pD,CFG.colors.pool);
  const wtMat=new THREE.MeshBasicMaterial({color:0x00aaff, transparent:true, opacity:0.6, side:THREE.DoubleSide}), wt=new THREE.Mesh(new THREE.PlaneGeometry(pW-wT*2,pD-wT*2), wtMat);
  wt.rotation.x=-Math.PI/2; wt.position.set(pX,3.0,pZ); scene.add(wt);
  const psW=4, psL=20, psX=pX-pW/2-psW/2, psZ=pZ, psH=3.0, psAng=Math.atan2(psH, psL);
  const psThickness=0.4, psB=new CANNON.Body({mass:0,material:mat});
  psB.addShape(new CANNON.Box(new CANNON.Vec3(psW/2, psThickness/2, Math.sqrt(psL*psL+psH*psH)/2)));
  psB.position.set(psX, psH/2-psThickness/2, psZ); psB.quaternion.setFromEuler(-psAng,0,0); world.addBody(psB);
  const psM=new THREE.Mesh(new THREE.BoxGeometry(psW,psThickness,Math.sqrt(psL*psL+psH*psH)), new THREE.MeshStandardMaterial({color:0xcccccc}));
  psM.position.copy(psB.position); psM.quaternion.copy(psB.quaternion); psM.receiveShadow=true; scene.add(psM);
  const pfH=1.5, pOutW=pW+2, pOutD=pD+2; const cf=(x,z,w,d)=>{const f=new THREE.Mesh(new THREE.BoxGeometry(w,pfH,d),new THREE.MeshStandardMaterial({color:0xdddddd,transparent:true,opacity:0.3}));f.position.set(x,2.0+pfH/2,z);scene.add(f);const b=new CANNON.Body({mass:0});b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,pfH/2,d/2)));b.position.copy(f.position);world.addBody(b);};
  cf(pX+pOutW/2, pZ, 0.2, pOutD); cf(pX, pZ-pOutD/2, pOutW, 0.2); cf(pX, pZ+pOutD/2, pOutW, 0.2);
  const gap=14; cf(pX-pOutW/2, pZ-(pD/2+gap)/2, 0.2, pD/2-gap); cf(pX-pOutW/2, pZ+(pD/2+gap)/2, 0.2, pD/2-gap);
  const gZ=FD/2; createBox(-15,5,gZ,5,10,5,0x888888); createBox(15,5,gZ,5,10,5,0x888888); createBox(0,4,gZ,25,8,1,0x555555);
}

function setupInputs(){
  els.stick.addEventListener('touchstart',e=>{e.preventDefault();if(stickId!==null)return;const t=e.changedTouches[0];stickId=t.identifier;const r=els.stick.getBoundingClientRect();stickStart={x:r.left+r.width/2,y:r.top+r.height/2};tapTime=Date.now();tapPos={x:t.clientX,y:t.clientY};moveStick(t.clientX,t.clientY);},{passive:false});
  els.stick.addEventListener('touchmove',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===stickId)moveStick(e.changedTouches[i].clientX,e.changedTouches[i].clientY);},{passive:false});
  const endStick=e=>{for(let i=0;i<e.changedTouches.length;i++){const t=e.changedTouches[i];if(t.identifier===stickId){if(Date.now()-tapTime<200&&Math.hypot(t.clientX-tapPos.x,t.clientY-tapPos.y)<15){if(playerBody&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;}stickId=null;input.x=0;input.y=0;els.knob.style.transform='translate(-50%,-50%)';}}};
  els.stick.addEventListener('touchend',endStick);els.stick.addEventListener('touchcancel',endStick);
  function moveStick(cx,cy){let dx=cx-stickStart.x,dy=cy-stickStart.y;const d=Math.hypot(dx,dy),max=(els.stick.offsetWidth/2)*0.8;if(d>max){dx*=max/d;dy*=max/d;}input.x=dx/max;input.y=dy/max;els.knob.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;}
  renderer.domElement.addEventListener('touchstart',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++){if(lookId===null&&e.changedTouches[i].target===renderer.domElement){lookId=e.changedTouches[i].identifier;lastLook={x:e.changedTouches[i].clientX,y:e.changedTouches[i].clientY};}}},{passive:false});
  renderer.domElement.addEventListener('touchmove',e=>{e.preventDefault();if(lookId===null)return;for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===lookId){const t=e.changedTouches[i];camAngle.yaw-=(t.clientX-lastLook.x)*0.004;camAngle.pitch-=(t.clientY-lastLook.y)*0.004;camAngle.pitch=Math.max(-1.5,Math.min(1.5,camAngle.pitch));lastLook={x:t.clientX,y:t.clientY};}}},{passive:false});
  const endLook=e=>{for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===lookId)lookId=null;};
  renderer.domElement.addEventListener('touchend',endLook);
  els.btnJump.addEventListener('touchstart',e=>{e.preventDefault();if(playerBody&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;});
  els.btnDist.addEventListener('touchstart',e=>{e.preventDefault();currentDist=(currentDist===CFG.dist.near)?CFG.dist.far:CFG.dist.near;els.distLabel.textContent=(currentDist===CFG.dist.near)?"近":"遠";showMsg(`射程: ${els.distLabel.textContent}`,"#fff");});
  els.btnAct.addEventListener('touchstart',e=>{e.preventDefault();if(actId!==null)return;const t=e.changedTouches[0];actId=t.identifier;actStartPos={x:t.clientX,y:t.clientY};});
  els.btnAct.addEventListener('touchend',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===actId){const t=e.changedTouches[i];if(Math.hypot(t.clientX-actStartPos.x,t.clientY-actStartPos.y)>20)actionKai();else actionMetsu();actId=null;}}});
  
  // モード切替
  els.modeBtn.addEventListener('touchstart',e=>{e.preventDefault(); e.stopPropagation();
    isPhysMode = !isPhysMode;
    els.modeBtn.textContent = isPhysMode ? "モード: 顕現" : "モード: 幽体";
    els.modeBtn.className = isPhysMode ? "phys" : "ghost";
    els.btnDraw.style.background = isPhysMode ? "linear-gradient(135deg, #FFD700, #FF8C00)" : "linear-gradient(135deg, #03a9f4, #0288d1)";
    els.btnDraw.innerHTML = isPhysMode ? "顕<br><span style='font-size:10px'>Hold</span>" : "結<br><span style='font-size:10px'>Hold</span>";
    showMsg(isPhysMode ? "物理顕現モード" : "幽体結界モード", "#fff");
  });

  // 結界ボタン
  els.btnDraw.addEventListener('touchstart',e=>{
    e.preventDefault(); if(drawId!==null)return; if(kekkaiList.length>=CFG.kekkai.max){showMsg("上限到達","#f44");return;}
    const t=e.changedTouches[0]; drawId=t.identifier; els.btnDraw.classList.add('drawing');
    if(isPhysMode) {
      activePhysKekkai = createActiveKekkai(); activePhysKekkai.startX=t.clientX; activePhysKekkai.startY=t.clientY;
    } else {
      drawState.active=true; drawState.startX=t.clientX; drawState.startY=t.clientY;
      const gg=new THREE.BoxGeometry(1,1,1), gm=new THREE.MeshBasicMaterial({color:CFG.colors.ghost,wireframe:true});
      drawState.ghost=new THREE.Mesh(gg,gm); drawState.ghost.position.copy(aimMarker.position); drawState.ghost.rotation.y=camAngle.yaw; scene.add(drawState.ghost);
    }
  });
  els.btnDraw.addEventListener('touchmove',e=>{
    e.preventDefault(); if(drawId===null)return;
    for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===drawId){
      const t=e.changedTouches[i];
      if(isPhysMode && activePhysKekkai) {
        const dx=Math.abs(t.clientX-activePhysKekkai.startX)*0.06, dy=(activePhysKekkai.startY-t.clientY)*0.06;
        updateActiveKekkai(activePhysKekkai, dx, dy);
      } else if(drawState.active && drawState.ghost) {
        const dx=Math.abs(t.clientX-drawState.startX)*0.06, dy=(drawState.startY-t.clientY)*0.06;
        const sxz=1.0+Math.max(0,dx), sy=1.0+Math.max(0,dy); drawState.ghost.scale.set(sxz,sy,sxz); drawState.ghost.position.y=aimMarker.position.y+(sy/2-0.5);
      }
    }}
  });
  els.btnDraw.addEventListener('touchend',e=>{
    e.preventDefault(); for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===drawId){
      if(isPhysMode && activePhysKekkai) { finalizeKekkai(activePhysKekkai); activePhysKekkai=null; }
      else if(drawState.ghost) { createKekkai(drawState.ghost.position,drawState.ghost.scale,drawState.ghost.rotation.y); scene.remove(drawState.ghost); drawState.ghost=null; drawState.active=false; }
      drawId=null; els.btnDraw.classList.remove('drawing');
    }}
  });
}

function createActiveKekkai() {
  const p = aimMarker.position.clone(); const r = camAngle.yaw;
  const b = new CANNON.Body({mass:0, material:new CANNON.Material('kek')});
  b.position.copy(p); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), r); world.addBody(b);
  const g = new THREE.BoxGeometry(1,1,1);
  const m = new THREE.MeshPhongMaterial({color:0xffff00, transparent:true, opacity:0.5, side:THREE.DoubleSide});
  const mesh = new THREE.Mesh(g, m); mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({color:0xffffff})));
  mesh.position.copy(p); mesh.rotation.y = r; scene.add(mesh);
  return { body:b, mesh:mesh, startP:p, startR:r };
}
function updateActiveKekkai(k, dx, dy) {
  const sx = 1.0 + Math.max(0, dx), sy = 1.0 + Math.max(0, dy), sz = sx;
  k.mesh.scale.set(sx, sy, sz);
  const newY = k.startP.y + (sy - 1.0)/2; k.mesh.position.y = newY; k.body.position.y = newY;
  k.body.shapes = []; k.body.addShape(new CANNON.Box(new CANNON.Vec3(sx/2, sy/2, sz/2)));
}
function finalizeKekkai(k) {
  k.mesh.material.color.setHex(CFG.colors.kekkai); k.mesh.material.opacity = 0.3;
  kekkaiList.push({ body:k.body, mesh:k.mesh, shrinking:false }); spawnText("顕", k.mesh.position, "#ff0"); updateHUD();
}

function updateAimMarker(){const e=new THREE.Euler(camAngle.pitch,camAngle.yaw,0,'YXZ'),d=new THREE.Vector3(0,0,-1).applyEuler(e),p=playerGroup.position.clone().add(d.multiplyScalar(currentDist));p.y=Math.max(0.5,p.y);aimMarker.position.copy(p);}
function createKekkai(p,s,r){const b=new CANNON.Body({mass:0,material:new CANNON.Material('kek')});b.position.copy(p);b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0),r);const t=0.5,x=s.x/2,y=s.y/2,z=s.z/2,aw=(d,o)=>b.addShape(new CANNON.Box(d),o);aw(new CANNON.Vec3(t,y,z),new CANNON.Vec3(-x,0,0));aw(new CANNON.Vec3(t,y,z),new CANNON.Vec3(x,0,0));aw(new CANNON.Vec3(x,t,z),new CANNON.Vec3(0,-y,0));aw(new CANNON.Vec3(x,t,z),new CANNON.Vec3(0,y,0));aw(new CANNON.Vec3(x,y,t),new CANNON.Vec3(0,0,-z));aw(new CANNON.Vec3(x,y,t),new CANNON.Vec3(0,0,z));world.addBody(b);const g=new THREE.BoxGeometry(s.x,s.y,s.z),m=new THREE.MeshPhongMaterial({color:CFG.colors.kekkai,transparent:true,opacity:0.3,side:THREE.DoubleSide}),mesh=new THREE.Mesh(g,m);mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g),new THREE.LineBasicMaterial({color:0xffffff})));mesh.position.copy(p);mesh.rotation.y=r;scene.add(mesh);kekkaiList.push({body:b,mesh:mesh,shrinking:false});spawnText("結",p,"#0ff");updateHUD();}
function removeKekkai(k){scene.remove(k.mesh);world.removeBody(k.body);kekkaiList=kekkaiList.filter(o=>o!==k);updateHUD();}
function actionMetsu(){let t=null,minD=999;kekkaiList.forEach(k=>{const d=playerBody.position.distanceTo(k.body.position);if(d<minD){minD=d;t=k;}});if(!t||t.shrinking){showMsg("対象なし","#888");return;}showMsg("滅！","#f24");spawnText("滅",t.mesh.position,"#f24");t.shrinking=true;t.mesh.material.color.setHex(0xff0044);const bbox=new THREE.Box3().setFromObject(t.mesh);let sc=1.0;const loop=()=>{if(!kekkaiList.includes(t))return;sc-=0.05;t.mesh.scale.setScalar(sc);enemies.forEach(e=>{if(bbox.containsPoint(e.mesh.position)){const d=t.body.position.vsub(e.body.position);e.body.velocity.set(d.x*8,d.y*8,d.z*8);if(sc<0.4)killEnemy(e);}});if(sc<=0.1){removeKekkai(t);spawnParticle(t.mesh.position,30,0xffaa00);}else requestAnimationFrame(loop);};loop();}
function actionKai(){const t=kekkaiList[kekkaiList.length-1];if(t){showMsg("解","#4f8");spawnText("解",t.mesh.position,"#4f8");removeKekkai(t);}else showMsg("結界なし","#888");}
function spawnEnemy(){if(enemies.length>=6+gameState.wave)return;const r=Math.random();let x,y,z;const sb={x:CFG.field.width/2+10,z:CFG.field.depth/2+10};if(r<0.6){const rx=CFG.field.width/2-10,rz=CFG.field.depth/2-10;x=(Math.random()-.5)*2*rx;z=(Math.random()-.5)*2*rz;y=20;}else if(r<0.8){const fw=CFG.field.width;x=(Math.random()-.5)*(fw-5);z=(-CFG.field.depth/2-20)+(Math.random()-.5)*30;y=35;}else{const px=CFG.field.width/2-25,pz=0;x=px+(Math.random()-.5)*20;z=pz+(Math.random()-.5)*50;y=10;}const sz=0.6+Math.random()*0.8,cl=new THREE.Color().setHSL(Math.random(),0.8,0.5),ms=15*sz,b=new CANNON.Body({mass:ms,shape:new CANNON.Sphere(sz),material:new CANNON.Material('ene'),linearDamping:0.4});b.position.set(x,y,z);world.addBody(b);b.outsideTimer=0;let g;const rr=Math.random();if(rr<0.3)g=new THREE.IcosahedronGeometry(sz,0);else if(rr<0.6)g=new THREE.OctahedronGeometry(sz,0);else g=new THREE.SphereGeometry(sz,16,16);const m=new THREE.Mesh(g,new THREE.MeshStandardMaterial({color:cl,roughness:0.3}));scene.add(m);enemies.push({body:b,mesh:m});updateHUD();}
function killEnemy(e){if(!enemies.includes(e))return;enemies=enemies.filter(o=>o!==e);scene.remove(e.mesh);world.removeBody(e.body);spawnParticle(e.mesh.position,25,e.mesh.material.color.getHex());gameState.kills++;gameState.req--;if(gameState.req<=0){gameState.wave++;gameState.req=gameState.wave*2+4;showMsg(`WAVE ${gameState.wave}`,"#fe0");}updateHUD();}
function removeEnemy(e){if(!enemies.includes(e))return;enemies=enemies.filter(o=>o!==e);scene.remove(e.mesh);world.removeBody(e.body);updateHUD();}
function updateHUD(){els.wVal.textContent=gameState.wave;els.kVal.textContent=gameState.kills;els.tVal.textContent=gameState.req;els.kekVal.textContent=kekkaiList.length;}
function showMsg(t,c){els.msg.textContent=t;els.msg.style.color=c;els.msg.style.opacity=1;setTimeout(()=>els.msg.style.opacity=0,800);}
function spawnText(s,p,c){const cvs=document.createElement('canvas');cvs.width=64;cvs.height=64;const ctx=cvs.getContext('2d');ctx.font="bold 48px sans-serif";ctx.fillStyle=c;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(s,32,32);const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cvs),transparent:true}));sp.position.copy(p);sp.scale.set(3,3,3);scene.add(sp);let f=0;const a=()=>{f+=0.03;sp.position.y+=0.05;sp.material.opacity=1-f;if(f<1)requestAnimationFrame(a);else{scene.remove(sp);sp.material.map.dispose();}};a();}
function spawnParticle(p,n,c){const g=new THREE.BoxGeometry(0.25,0.25,0.25),m=new THREE.MeshBasicMaterial({color:c});for(let i=0;i<n;i++){const me=new THREE.Mesh(g,m);me.position.copy(p).add(new THREE.Vector3((Math.random()-.5)*2,(Math.random()-.5)*2,(Math.random()-.5)*2));scene.add(me);const v=new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5).multiplyScalar(1.5);const a=()=>{me.position.add(v);me.scale.multiplyScalar(0.92);if(me.scale.x>0.05)requestAnimationFrame(a);else scene.remove(me);};a();}}

let lastT=0, vrState={lastDraw:false,lastAct:false,lastDist:false,lastMode:false};
function loop(t){
  const dt=Math.min((t-lastT)/1000,0.1); lastT=t;
  world.step(1/60, dt, 3);
  if(renderer.xr.isPresenting){
    const s=renderer.xr.getSession();
    if(s){
      for(const src of s.inputSources){
        if(!src.gamepad)continue;const gp=src.gamepad;
        if(src.handedness==='left'&&gp.axes.length>=4){input.x=gp.axes[2];input.y=gp.axes[3];}
        if(src.handedness==='right'&&gp.axes.length>=4){
          if(Math.abs(gp.axes[2])>0.5)camAngle.yaw-=gp.axes[2]*0.04;
          if(gp.buttons[4]?.pressed&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;
          
          // モード切替 (右スティック押し込み)
          if(gp.buttons[3]?.pressed && !vrState.lastMode) {
             isPhysMode = !isPhysMode; showMsg(isPhysMode?"顕現モード":"幽体モード", "#fff");
          }
          vrState.lastMode = gp.buttons[3]?.pressed;

          if(gp.buttons[0]?.pressed){
            if(!drawId) drawId='vr';
            if(isPhysMode) {
              if(!activePhysKekkai) { activePhysKekkai=createActiveKekkai(); activePhysKekkai.startX=0; activePhysKekkai.startY=0; activePhysKekkai.body.position.copy(aimMarker.position); }
              // VRでは時間経過で拡大させる
              const scale = 1.0 + (Date.now()%1000)/500; // 簡易
              updateActiveKekkai(activePhysKekkai, scale-1, scale-1);
              activePhysKekkai.body.position.copy(aimMarker.position).y += (activePhysKekkai.currentS.y/2);
              activePhysKekkai.mesh.position.copy(activePhysKekkai.body.position);
            } else {
              if(!drawState.active && kekkaiList.length<CFG.kekkai.max){
                drawState.active=true; const gg=new THREE.BoxGeometry(1,1,1),gm=new THREE.MeshBasicMaterial({color:CFG.colors.ghost,wireframe:true});
                drawState.ghost=new THREE.Mesh(gg,gm); scene.add(drawState.ghost);
              }
              if(drawState.ghost){
                drawState.ghost.position.copy(aimMarker.position); drawState.ghost.rotation.y=camAngle.yaw;
                drawState.ghost.scale.set(3,3,3); drawState.ghost.position.y=aimMarker.position.y+1;
              }
            }
          }else{
            if(drawId==='vr'){
              if(isPhysMode && activePhysKekkai) { finalizeKekkai(activePhysKekkai); activePhysKekkai=null; }
              else if(drawState.active&&drawState.ghost){createKekkai(drawState.ghost.position,drawState.ghost.scale,drawState.ghost.rotation.y);scene.remove(drawState.ghost);drawState.ghost=null;drawState.active=false;}
              drawId=null;
            }
          }
          const act=gp.buttons[5]?.pressed;if(act&&!vrState.lastAct)actionMetsu();vrState.lastAct=act;
          const dst=gp.buttons[1]?.pressed;if(dst&&!vrState.lastDist){currentDist=(currentDist===CFG.dist.near)?CFG.dist.far:CFG.dist.near;showMsg(currentDist===CFG.dist.near?"近":"遠","#fff");}vrState.lastDist=dst;
        }
      }
    }
    const cam=renderer.xr.getCamera(),d=new THREE.Vector3();cam.getWorldDirection(d);d.y=0;d.normalize();
    const r=new THREE.Vector3().crossVectors(d,new THREE.Vector3(0,1,0)),m=d.multiplyScalar(-input.y).add(r.multiplyScalar(input.x)).multiplyScalar(CFG.player.speed);
    playerBody.velocity.x=m.x;playerBody.velocity.z=m.z;playerGroup.position.copy(playerBody.position);
  }else{
    const yaw=camAngle.yaw,fwd=new THREE.Vector3(input.x,0,input.y).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
    playerBody.velocity.x=fwd.x*CFG.player.speed;playerBody.velocity.z=fwd.z*CFG.player.speed;
    playerGroup.position.copy(playerBody.position).add(new THREE.Vector3(0,CFG.player.height,0));
    playerGroup.rotation.y=yaw;camera.rotation.x=camAngle.pitch;
  }
  updateAimMarker();
  if(t>gameState.nextSpawn){spawnEnemy();gameState.nextSpawn=t+3000-gameState.wave*100;}
  const fW=CFG.field.width, fD=CFG.field.depth;
  enemies.forEach(e=>{
    e.mesh.position.copy(e.body.position); e.mesh.quaternion.copy(e.body.quaternion);
    if(e.body.position.y<-10)killEnemy(e);
    const isOut=Math.abs(e.body.position.x)>fW/2+2 || Math.abs(e.body.position.z)>fD/2+2;
    if(isOut){
      if(!e.body.outsideTimer)e.body.outsideTimer=0; e.body.outsideTimer+=dt;
      if(e.body.outsideTimer>20.0){showMsg("敵逃亡!","#aaa");removeEnemy(e);return;}
      const cu=new CANNON.Vec3(0,25,0), dr=cu.vsub(e.body.position); dr.normalize(); e.body.applyForce(dr.scale(40),e.body.position);
    }else{
      e.body.outsideTimer=0; const d=playerBody.position.vsub(e.body.position);d.normalize();e.body.applyForce(d.scale(20),e.body.position);
    }
  });
  renderer.render(scene,camera);
}
document.getElementById('vrBtn').addEventListener('click', ()=>{ if(navigator.xr) navigator.xr.requestSession('immersive-vr').then(s=>{ renderer.xr.setSession(s); document.getElementById('uiLayer').style.display='none'; }); });
window.onload = init;
</script>
</body>
</html>
